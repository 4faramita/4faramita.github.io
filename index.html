<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>之言片语</title>

  
  <meta name="author" content="4faramita">
  

  
  <meta name="description" content="Buried alive.">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="之言片语"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="之言片语" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">之言片语</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/tags/algorithm">Algorithms</a></li>
      
        <li><a href="/tags/thinking">Thoughts</a></li>
      
        <li><a href="/tags/works">Works</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/17/maximum-subarray/"><span>53. Maximum Subarray</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/17/maximum-subarray/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-17T07:00:18.000Z">
          2017-03-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p></p><p><br>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.<br></p><br><p><br>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br><br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.<br></p>

<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show more practice.</a></p>

<div class="spoilers"><b>More practice:</b><br><br><p>If you have figured out the O(<i>n</i>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><br></div>

<p><b>题意:</b><br><br>给出一数组 nums，求数组中和最大的连续子序列。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>最简单的想法自然是枚举所有大小的窗口，从 len(nums) 到 1；滑动窗口到每个可能的位置，求和，记录和的最大值。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="comment"># base cases</span></div><div class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> len(nums) == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</div><div class="line">        </div><div class="line">        <span class="comment"># window size init as len(nums) - 1</span></div><div class="line">        window = len(nums) - <span class="number">1</span></div><div class="line">        <span class="comment"># window position init as right</span></div><div class="line">        start = len(nums) - window</div><div class="line">        <span class="comment"># this is the case when window size = len(nums)</span></div><div class="line">        <span class="comment"># and this will store the max of sums</span></div><div class="line">        sum_max = sum(nums)</div><div class="line">        </div><div class="line">        <span class="comment"># every possible window size: [1, len(nums) - 1]</span></div><div class="line">        <span class="keyword">while</span> window &gt; <span class="number">0</span>:</div><div class="line">            <span class="comment"># every possible position of this window</span></div><div class="line">            <span class="keyword">while</span> start &gt;= <span class="number">0</span>:</div><div class="line">                sum_curr = sum(nums[start:start+window])</div><div class="line">                sum_max = max(sum_curr, sum_max)</div><div class="line">                <span class="comment"># window slides left</span></div><div class="line">                start -= <span class="number">1</span></div><div class="line">            <span class="comment"># window size minus 1</span></div><div class="line">            window -= <span class="number">1</span></div><div class="line">            <span class="comment"># reset window position to the very right</span></div><div class="line">            start = len(nums) - window</div><div class="line">        <span class="keyword">return</span> sum_max</div></pre></td></tr></table></figure>
<p>不用说，这么 virgin 这么 naive 的算法当然是无法满足时间复杂度要求的。<br>之后，我考虑窗口从 1 开始，用字典储存所有算过的 sum，下次使用时直接读取而不用再算一遍。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(nums)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :type nums: List[int]</div><div class="line">    :rtype: int</div><div class="line">    """</div><div class="line">    <span class="comment"># base cases</span></div><div class="line">    length = len(nums)</div><div class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">elif</span> length == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</div><div class="line"></div><div class="line">    <span class="comment"># all possible window sizes in [1, length - 1]</span></div><div class="line">    window = <span class="number">1</span></div><div class="line">    <span class="comment"># all possible positions from right</span></div><div class="line">    start = len(nums) - window</div><div class="line">    <span class="comment"># stroe the max of sums</span></div><div class="line">    sum_max = sum(nums)</div><div class="line">    <span class="comment"># store all sums for every position of every window sizes</span></div><div class="line">    sum_set = &#123;&#125;</div><div class="line">    <span class="keyword">while</span> window &lt; length:</div><div class="line">        <span class="keyword">while</span> start &gt;= <span class="number">0</span>:</div><div class="line">            <span class="comment"># store all single "sums"</span></div><div class="line">            <span class="keyword">if</span> window == <span class="number">1</span>:</div><div class="line">                sum_curr = nums[start]</div><div class="line">            <span class="comment"># get current sum by last round sum + single "sum"</span></div><div class="line">            <span class="keyword">elif</span> window &gt; <span class="number">1</span>:</div><div class="line">                sum_curr = sum_set[(start, start + window - <span class="number">1</span>)] + nums[start + window - <span class="number">1</span>]</div><div class="line">            <span class="comment"># store current sum</span></div><div class="line">            sum_set[(start, start+window)] = sum_curr</div><div class="line"></div><div class="line">            <span class="comment"># print(nums[start:start+window], sum_curr, sum_max)</span></div><div class="line"></div><div class="line">            <span class="comment"># store current max sum</span></div><div class="line">            sum_max = max(sum_curr, sum_max)</div><div class="line">            <span class="comment"># slide the window</span></div><div class="line">            start -= <span class="number">1</span></div><div class="line">        <span class="comment"># enlarge the window size</span></div><div class="line">        window += <span class="number">1</span></div><div class="line">        <span class="comment"># and reset the position of the window</span></div><div class="line">        start = len(nums) - window</div><div class="line">    <span class="keyword">return</span> sum_max</div></pre></td></tr></table></figure>
<p>这个算法则将执行时间从原来的 2.5s 优化到了 1s 以内。<br>但是时间复杂度依然是 O(n^2)</p>
<p>这道题是可以用动态规划的。遍历到每个节点时都有两个选择：选择上一个 sum 加当前数，或者选择当前数作为新的 sum。<br>算法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> A:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line"></div><div class="line">    curSum = maxSum = A[<span class="number">0</span>]</div><div class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> A[<span class="number">1</span>:]:</div><div class="line">        curSum = max(num, curSum + num)</div><div class="line">        maxSum = max(maxSum, curSum)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> maxSum</div></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/17/maximum-subarray/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/17/valid-palindrome/"><span>125. Valid Palindrome</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/17/valid-palindrome/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-17T05:49:24.000Z">
          2017-03-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p></p><p><br>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.<br></p>

<p><br>For example,<br><br><code>“A man, a plan, a canal: Panama”</code> is a palindrome.<br><br><code>“race a car”</code> is <i>not</i> a palindrome.<br></p>

<p><br><b>Note:</b><br><br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p><br><p><br>For the purpose of this problem, we define empty string as valid palindrome.<br></p>

<p><b>题意:</b><br><br>给出一个字符串，判断是否为回文。<br>要求：</p>
<ul>
<li>空字符串为回文；</li>
<li>忽略非字母数字的字符；</li>
<li>大小写不敏感。</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>算法并不难，字符串转小写，过滤非数字与非字母，切分字符串为前后两半，对比即可。<br>OJ 的最后一个 test case 是一个长达 14380 行的复杂字符串，该算法可以在 0.07s 内完成判断。<br>但是！这个算法依然超过了时间限制！<br>F！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> s == <span class="string">''</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        s = s.lower()</div><div class="line">        s_clean = <span class="string">''</span></div><div class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> c.isalpha() <span class="keyword">or</span> c.isdigit():</div><div class="line">                s_clean += c</div><div class="line">        length = len(s_clean)</div><div class="line">        <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">            s_l = s_clean[:length / <span class="number">2</span>]</div><div class="line">            s_r = s_clean[length / <span class="number">2</span>:]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            s_l = s_clean[:(length - <span class="number">1</span>) / <span class="number">2</span>]</div><div class="line">            s_r = s_clean[(length + <span class="number">1</span>) / <span class="number">2</span>:]</div><div class="line">        <span class="keyword">return</span> s_l == s_r[::<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<p>于是我写了另一个算法，使用双指针原地执行。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        head, tail = <span class="number">0</span>, len(s) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> tail &gt; head:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s[tail].isalnum():</div><div class="line">                tail -= <span class="number">1</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s[head].isalnum():</div><div class="line">                head += <span class="number">1</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> s[tail].lower() != s[head].lower():</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            tail -= <span class="number">1</span></div><div class="line">            head += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>这个算法在处理上面提到的大字符串时运行时间稳定在 0.75s，然而 LeetCodeOJ 竟然判断通过。</p>
<p>当然，原地执行达到相似时间复杂度的确是更好的实践。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/17/valid-palindrome/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/16/count-primes/"><span>204. Count Primes</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/16/count-primes/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T15:07:28.000Z">
          2017-03-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong> (Which I do not agree AT ALL.)</p>
<p></p><p><b>Description:</b></p><br><p>Count the number of prime numbers less than a non-negative number, <b><i>n</i></b>.</p>

<p><b>题意:</b><br><br>输入一个数，输出小于这个数的所有正整数中有多少个质数。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很多数的素性检测。时间复杂度是关键。<br>最简单的想法是遍历每个数，检查每个数的素性。尽管检查素性的函数效率不低，但是总体效率还是非常低</p>
<p>一番查找之后，我选择了埃拉托斯特尼筛法。这是一个古老而简单的算法，用来找出一定范围内所有素数，流程如下：</p>
<ul>
<li>初始化两个数列 nums 和 status，nums 储存从 2 开始所有待查的数（因为 1 不是素数），status 储存 nums 中每个数是否为素数，初始化为 True。</li>
<li>从第一个元素 2 开始，将 nums 中每一个该元素（这里为 2） 的倍数标记为合数，方法是将 status 数组对应位置赋值 False。</li>
<li>当最近检查出的素数的平方已经大于 nums 中最大的数时，认为之后所有未标记为合数的数都是质数，算法结束。<br>代码如下<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="comment"># base cases</span></div><div class="line">        <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">and</span> n &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> n &lt;= <span class="number">4</span>:</div><div class="line">            <span class="keyword">return</span> n - <span class="number">2</span></div><div class="line">    </div><div class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n)]  <span class="comment"># all the numbers</span></div><div class="line">        status = [<span class="keyword">True</span>] * len(nums)      <span class="comment"># whether a number in nums a prime</span></div><div class="line">        last_prime = <span class="number">0</span>                   <span class="comment"># store the last prime found</span></div><div class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> enumerate(nums):     <span class="comment"># elem: (position, value)</span></div><div class="line">            <span class="keyword">if</span> (last_prime ** <span class="number">2</span>) &gt; n - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> status[elem[<span class="number">0</span>]] <span class="keyword">is</span> <span class="keyword">False</span>:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">    </div><div class="line">            last_prime = elem[<span class="number">1</span>]</div><div class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> range(elem[<span class="number">0</span>] + <span class="number">1</span>, len(nums)):</div><div class="line">                <span class="keyword">if</span> nums[p] % elem[<span class="number">1</span>] == <span class="number">0</span>:</div><div class="line">                    status[p] = <span class="keyword">False</span></div><div class="line">    </div><div class="line">        total = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> status:</div><div class="line">            <span class="keyword">if</span> j <span class="keyword">is</span> <span class="keyword">True</span>:</div><div class="line">                total += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> total</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然而，令人难以置信的是，这个算法，在输入值为六位数时，依然超过了时间限制（具体来说执行时间达到了十秒以上）。</p>
<p>于是我不甘心地点开了这道题的 hint 部分。这道题的 hint，锦囊一般，层层嵌套，一个问题引出另一个问题，なんと、有整整八个 hint！前半部分也引导使用每个数的素性检测，之后说只需要检测前 n／2 的数，更进一步发现只需要检测前 n^(1/2) 的数。之后也引出了我之前提到的埃拉托斯特尼筛法，该方法确实是检测大批量数是否为素的好方法。我按照 hint 的引导优化了算法，再次实验。</p>
<p>随着不断修改，最终我将步长改为动态，优化了一系列事件与内存复杂度。最终能在 1s 内执行。<br>因为进行了许多优化，最终答案中也包含许多注释，更多的优化内容在注释中说明。<br>当然，我看答案了，但是最终的算法完全是我根据之前写的 8s 的答案独立修改而来的。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="comment"># base cases</span></div><div class="line">        <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">and</span> n &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> n &lt;= <span class="number">4</span>:</div><div class="line">            <span class="keyword">return</span> n - <span class="number">2</span></div><div class="line">        </div><div class="line">        <span class="comment"># all the nums = [i for i in xrange(n)]</span></div><div class="line">        <span class="comment"># but, as rank and value of nums are the same</span></div><div class="line">        <span class="comment"># as a matter of fact,</span></div><div class="line">        <span class="comment"># they all equal to the natural number of that position</span></div><div class="line">        <span class="comment"># so there\'s no need to actually create that list</span></div><div class="line">        </div><div class="line">        <span class="comment"># every nums\' status, True for prime</span></div><div class="line">        status = [<span class="keyword">True</span>] * n</div><div class="line">        <span class="comment"># 0 and 1 are not primes</span></div><div class="line">        status[<span class="number">0</span>], status[<span class="number">1</span>] = <span class="keyword">False</span>, <span class="keyword">False</span></div><div class="line">        <span class="comment"># without list(nums)</span></div><div class="line">        <span class="comment"># I can still do this step</span></div><div class="line">        <span class="comment"># thanks to the natural number</span></div><div class="line">        <span class="comment"># in the range of [2, sqrt(n - 1)]</span></div><div class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> xrange(<span class="number">2</span>, int((n - <span class="number">1</span>) ** <span class="number">0.5</span>) + <span class="number">1</span>):</div><div class="line">            <span class="comment"># if this num is a prime</span></div><div class="line">            <span class="keyword">if</span> status[elem]:</div><div class="line">                <span class="comment"># from position num ^ 2</span></div><div class="line">                p = elem ** <span class="number">2</span></div><div class="line">                <span class="comment"># every step num</span></div><div class="line">                <span class="comment"># set status False</span></div><div class="line">                <span class="keyword">while</span> p &lt; n:</div><div class="line">                    status[p] = <span class="keyword">False</span></div><div class="line">                    p += elem</div><div class="line">        <span class="comment"># return number of Tures</span></div><div class="line">        <span class="keyword">return</span> sum(status)</div></pre></td></tr></table></figure>
<p>鉴于 hint 过多，之前写的脚本又没能抓回来，现将网址贴出：<br><a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="external">204. Count Primes</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/16/count-primes/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/16/min-stack/"><span>155. Min Stack</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/16/min-stack/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T10:29:32.000Z">
          2017-03-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p></p><p></p><p><br>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.<br></p><ul><p></p>
<p><li><br>push(x) – Push element x onto stack.<br></li></p>
<p><li><br>pop() – Removes the element on top of the stack.<br></li></p>
<p><li><br>top() – Get the top element.<br></li></p>
<p><li><br>getMin() – Retrieve the minimum element in the stack.<br></li><br></p></ul><p></p>
<p></p><p><b>Example:</b><br><br></p><pre><br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; Returns -3.<br>minStack.pop();<br>minStack.top();      –&gt; Returns 0.<br>minStack.getMin();   –&gt; Returns -2.<br></pre><p></p>
<p><b>题意:</b><br><br>自己实现一个栈，除了推、弹、查看栈顶以外还要求常数时间找到栈中最小值。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>基本思路是使用 list 结构，自带 push（append）与 pop 方法。top 只需要返回最后一个元素。<br>对于最小值，最单纯的思路是用自带方法返回 min(list)，但是时间复杂度不允许。<br>因此维护一个最小值 stack，在每次 push 的时顺便在最小值 stack 中 push 当前最小值（包括输入值），每次 pop 时最小值栈也随之 pop。需要获取最小值时只需要获取最小值 stack 的最后一个元素即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        initialize your data structure here.</div><div class="line">        """</div><div class="line">        self.stack = []</div><div class="line">        self.min_q = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: void</div><div class="line">        """</div><div class="line">        self.stack.append(x)</div><div class="line">        <span class="keyword">if</span> self.min_q == []:</div><div class="line">            self.min_q.append(x)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.min_q.append(min(x, self.min_q[<span class="number">-1</span>]))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: void</div><div class="line">        """</div><div class="line">        self.stack.pop()</div><div class="line">        self.min_q.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> self.min_q[<span class="number">-1</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></div><div class="line"><span class="comment"># obj = MinStack()</span></div><div class="line"><span class="comment"># obj.push(x)</span></div><div class="line"><span class="comment"># obj.pop()</span></div><div class="line"><span class="comment"># param_3 = obj.top()</span></div><div class="line"><span class="comment"># param_4 = obj.getMin()</span></div></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/16/min-stack/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/16/intersection-of-two-linked-lists/"><span>160. Intersection of Two Linked Lists</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/16/intersection-of-two-linked-lists/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T09:18:58.000Z">
          2017-03-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>

<p>For example, the following two linked lists: </p><br><pre><br>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3<br></pre><br><p>begin to intersect at node c1.</p>

<p></p><p><b>Notes:</b><br></p><ul><p></p>
<p><li>If the two linked lists have no intersection at all, return <code>null</code>.</li></p>
<p><li>The linked lists must retain their original structure after the function returns. </li></p>
<p><li>You may assume there are no cycles anywhere in the entire linked structure.</li></p>
<p><li>Your code should preferably run in O(n) time and use only O(1) memory.</li><br></p></ul><p></p>
<p><b>题意:</b><br><br>两个链表，要求返回交叉点。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先遍历一遍，确定二者的长度。<br>从较长的一个开始遍历，直到二者长度相同，然后两个链表同时向后遍历，检测每一个点是不是点是不是相等<br>遍历两次，时间复杂度 O(n),；<br>新建四个指针，空间复杂度 O(1)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head1, head1: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        pt_a, pt_b = headA, headB</div><div class="line">        len_a, len_b = <span class="number">0</span>, <span class="number">0</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span> pt_a:</div><div class="line">            len_a += <span class="number">1</span></div><div class="line">            pt_a = pt_a.next</div><div class="line">        <span class="keyword">while</span> pt_b:</div><div class="line">            len_b += <span class="number">1</span></div><div class="line">            pt_b = pt_b.next</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> len_a &gt; len_b:</div><div class="line">            long, short = headA, headB</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            long, short = headB, headA</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> diff <span class="keyword">in</span> range(abs(len_a - len_b)):</div><div class="line">            long = long.next</div><div class="line">        </div><div class="line">        common = <span class="keyword">None</span></div><div class="line">        <span class="keyword">while</span> long:</div><div class="line">            <span class="keyword">if</span> long == short:</div><div class="line">                common = long</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                long, short = long.next, short.next</div><div class="line">        <span class="keyword">return</span> common</div></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/16/intersection-of-two-linked-lists/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/16/longest-common-prefix/"><span>14. Longest Common Prefix</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/16/longest-common-prefix/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T09:02:11.000Z">
          2017-03-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p></p><p>Write a function to find the longest common prefix string amongst an array of strings.<br></p>

<p><b>题意:</b><br><br>给出一 list，内容为一些字符串，找出这些字符串的最长公共前缀。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先将前缀 prefix 定位 list 的第一个元素。对于之后的每一个元素，如果该元素比 prefix 短，则先将 prefix 切成相应长度。然后对比 prefix 与当前元素，遇到不同则将 prefix 切成不同点之前的部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type strs: List[str]</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> strs == []:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span></div><div class="line">        <span class="keyword">elif</span> len(strs) == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</div><div class="line">    </div><div class="line">        prefix = strs[<span class="number">0</span>]</div><div class="line">    </div><div class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</div><div class="line">            <span class="keyword">if</span> s == <span class="string">''</span> <span class="keyword">or</span> prefix == <span class="string">''</span>:</div><div class="line">                <span class="keyword">return</span> <span class="string">''</span></div><div class="line">            prefix = prefix[:min(len(prefix), len(s))]</div><div class="line">            <span class="keyword">for</span> posi <span class="keyword">in</span> range(len(prefix)):</div><div class="line">                <span class="keyword">if</span> prefix[posi] != s[posi]:</div><div class="line">                    prefix = prefix[:posi]</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> len(prefix) == <span class="number">0</span>:</div><div class="line">                <span class="keyword">return</span> <span class="string">''</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> prefix</div></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/16/longest-common-prefix/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/16/merge-sorted-array/"><span>88. Merge Sorted Array</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/16/merge-sorted-array/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T08:31:03.000Z">
          2017-03-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p></p><p>Given two sorted integer arrays <i>nums1</i> and <i>nums2</i>, merge <i>nums2</i> into <i>nums1</i> as one sorted array.</p>

<p><br><b>Note:</b><br><br>You may assume that <i>nums1</i> has enough space (size that is greater or equal to <i>m</i> + <i>n</i>) to hold additional elements from <i>nums2</i>. The number of elements initialized in <i>nums1</i> and <i>nums2</i> are <i>m</i> and <i>n</i> respectively.</p>

<p><b>题意:</b><br><br>给两个有序数组 nums1、nums2，将两个数组原地合并到 nums1，保持 nums1 有序。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>与归并排序类似，但是从头部开始归并的成本太高，而 nums1 又有足够的长度，因此从两数组的尾部开始归并，放在 nums1 尾部（从 m + n - 1 开始）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums1: List[int]</div><div class="line">        :type m: int</div><div class="line">        :type nums2: List[int]</div><div class="line">        :type n: int</div><div class="line">        :rtype: void Do not return anything, modify nums1 in-place instead.</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        p1, p2 = m - <span class="number">1</span>, n - <span class="number">1</span>  <span class="comment"># 2 working pointers init at the ends</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> p1 &lt; <span class="number">0</span>:</div><div class="line">                nums1[i] = nums2[p2]</div><div class="line">                p2 -= <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> p2 &lt; <span class="number">0</span>:</div><div class="line">                nums1[i] = nums1[p1]</div><div class="line">                p1 -= <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> nums1[p1] &gt; nums2[p2]:</div><div class="line">                nums1[i] = nums1[p1]</div><div class="line">                p1 -= <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> nums1[p1] &lt;= nums2[p2]:</div><div class="line">                nums1[i] = nums2[p2]</div><div class="line">                p2 -= <span class="number">1</span></div></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/16/merge-sorted-array/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/14/palindrome-linked-list/"><span>234. Palindrome Linked List</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/14/palindrome-linked-list/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-14T08:18:22.000Z">
          2017-03-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p></p><p>Given a singly linked list, determine if it is a palindrome.</p>

<p><b>Follow up:</b><br><br>Could you do it in O(n) time and O(1) space?</p>

<p><b>题意:</b><br><br>判断一个链表是否回文。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>最简单的想法是把链表的值按顺序输出到一个数组，在判断数组是否回文；<br>判断数组是否回文，也就是判断前一半的逆序是否与后一半相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        link_list = []</div><div class="line">        p = head</div><div class="line">        <span class="keyword">while</span> p:</div><div class="line">            link_list.append(p.val)</div><div class="line">            p = p.next</div><div class="line">    </div><div class="line">        length = len(link_list)</div><div class="line">        <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> link_list[:(length / <span class="number">2</span>)] == link_list[(length / <span class="number">2</span>):][::<span class="number">-1</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> link_list[:(length / <span class="number">2</span>)] == link_list[(length / <span class="number">2</span>) + <span class="number">1</span>:][::<span class="number">-1</span>]</div></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/14/palindrome-linked-list/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/14/fizz-buzz/"><span>412. Fizz Buzz</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/14/fizz-buzz/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-14T07:38:00.000Z">
          2017-03-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p><strong>Example</strong><br>n = 15,</p>
<p>Return:<br>[<br>    “1”,<br>    “2”,<br>    “Fizz”,<br>    “4”,<br>    “Buzz”,<br>    “Fizz”,<br>    “7”,<br>    “8”,<br>    “Fizz”,<br>    “Buzz”,<br>    “11”,<br>    “Fizz”,<br>    “13”,<br>    “14”,<br>    “FizzBuzz”<br>]</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: List[str]</div><div class="line">        """</div><div class="line">        rslt = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</div><div class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">15</span> == <span class="number">0</span>:</div><div class="line">                rslt.append(<span class="string">'FizzBuzz'</span>)</div><div class="line">            <span class="keyword">elif</span> (i + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</div><div class="line">                rslt.append(<span class="string">'Buzz'</span>)</div><div class="line">            <span class="keyword">elif</span> (i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>:</div><div class="line">                rslt.append(<span class="string">'Fizz'</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                rslt.append(str(i + <span class="number">1</span>))</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> rslt</div></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/14/fizz-buzz/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/14/valid-parentheses/"><span>20. Valid Parentheses</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/14/valid-parentheses/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-14T06:35:45.000Z">
          2017-03-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>Difficulty: Easy</strong></p>
<p></p><p>Given a string containing just the characters <code>‘(‘</code>, <code>‘)’</code>, <code>‘{‘</code>, <code>‘}’</code>, <code>‘[‘</code> and <code>‘]’</code>, determine if the input string is valid.</p>

<p>The brackets must close in the correct order, <code>“()”</code> and <code>“()[]{}”</code> are all valid but <code>“(]”</code> and <code>“([)]”</code> are not.</p>

<p><b>题意:</b><br><br>输入一列括号组合，数出是否合法，即括号是否先打开后关闭并且以正确顺序关闭。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>实际上就是实现一个 stack。<br>这里使用 dict 类型来判断左右括号是否对应。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        left = &#123;<span class="string">'('</span>: <span class="number">0</span>, <span class="string">'['</span>: <span class="number">1</span>, <span class="string">'&#123;'</span>: <span class="number">2</span>&#125;    <span class="comment"># left dict</span></div><div class="line">        right = &#123;<span class="string">')'</span>: <span class="number">0</span>, <span class="string">']'</span>: <span class="number">1</span>, <span class="string">'&#125;'</span>: <span class="number">2</span>&#125;   <span class="comment"># right dict</span></div><div class="line">        stack = []                         <span class="comment"># working stack</span></div><div class="line">    </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:                        <span class="comment"># every element in s</span></div><div class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> left:                  <span class="comment"># if it's one of the lefts</span></div><div class="line">                stack.append(i)            <span class="comment"># stack push</span></div><div class="line">            <span class="keyword">elif</span> i <span class="keyword">in</span> right:               <span class="comment"># if it's one of the rights</span></div><div class="line">                <span class="keyword">try</span>:                       <span class="comment"># try to pop</span></div><div class="line">                    tmp = stack.pop()</div><div class="line">                <span class="keyword">except</span> IndexError:         <span class="comment"># if nothing to pop, return False</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                <span class="keyword">if</span> left[tmp] != right[i]:  <span class="comment"># if they do not match, return False</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> stack == []:                    <span class="comment"># stack must be empty</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/14/valid-parentheses/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 4faramita
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93516577-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>