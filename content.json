[{"title":"一个交作业的小工具","date":"2017-03-08T08:58:32.000Z","path":"2017/03/08/a-tool-for-homework/","text":"本博客基于 Hexo 搭建。Hexo 的文章格式虽然简单，但是每次手打也实在太麻烦。故写一小脚本帮助生成需要的作业格式。三个参数分别为文件名，标题与难度；除此以外还会自动填充当前时间。代码如下。 12345678910111213141516171819202122232425262728293031#!/usr/bin/python3# -*- coding: UTF-8 -*-import sysimport timetmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**## Solution'''tmp = tmp.format( title=sys.argv[2], difficulty=sys.argv[3], date=time.strftime(\"%F %H:%M:%S\", time.localtime()))tmp += (r'&#123;% codeblock lang:python %&#125;' + '\\n\\n' + r'&#123;% endcodeblock %&#125;' + '\\n')file = open(sys.argv[1] + '.md', 'w')file.write(tmp)file.close()print(sys.argv[1] + '.md') 之后还会对信息填充进一步优化，如从网页自动获取问题描述等。 人生苦短，我用 Python。","tags":[{"name":"thinking","slug":"thinking","permalink":"http://faramita.us/tags/thinking/"}]},{"title":"121. Best Time to Buy and Sell Stock","date":"2017-03-08T08:51:32.000Z","path":"2017/03/08/best-time-to-buy-and-sell-stock/","text":"DescriptionDifficulty: Easy Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. 给出一数组，代表每天的股价。要求只能买卖一次，求最大利润。 Solution实际上是求数组中后面的数与前面的数的最大差值。最简单的方法自然是两个循环，但是时间复杂度为 O(n^2)，很不理想。 思路：由于在每个单调区间中对答案有意义的元素只有区间两端的值而已。因此构建两个新数组，分别只包含每个单调区间的最大值与最小值。之后，针对最小值数组中每个元素，找最大值数组相应位置及之后的最大元素即可算出最大差值（利润） 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" max_profit = 0 if len(prices) == 2: return max(prices[1] - prices[0], 0) elif len(prices) &gt; 2: low = prices[0] high = prices[0] profit = 0 list_low = [prices[0]] list_high = [] up = True for i in xrange(len(prices) - 1): if prices[i + 1] &gt;= prices[i]: # going up high = prices[i + 1] if up == False: low = prices[i] list_low.append(low) up = True elif prices[i + 1] &lt; prices[i]: # going down low = prices[i + 1] if up == True: high = prices[i] list_high.append(high) up = False if len(list_high) &lt; len(list_low): list_high.append(prices[-1]) for j in xrange(len(list_low)): max_profit = max(max_profit, max(list_high[j:]) - list_low[j]) return max_profit","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"","date":"2017-03-08T08:02:24.000Z","path":"2017/03/08/sdsdsd/","text":"example.md","tags":[]},{"title":"268. Missing Number","date":"2017-03-07T12:46:00.000Z","path":"2017/03/07/missing-number/","text":"DescriptionDifficulty: Easy Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example,Given nums = [0, 1, 3] return 2. Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 给一数组，给出数组与 [0,1,2,3,4,…,n] 相比缺少的一个数。所给数组可为任意顺序。 Solution先排序。分析一下情况：数组长度为 0：缺 1数组长度为 1：有两种情况（因为只能缺一个数）[0], [1]；分别返回 1, 0数组更长：若第一个元素不是 0，则返回 0；设两个指针从开头遍历，若后一个减前一个大于 1，则返回前一个 + 1；若一直连续，这返回最后一个元素 + 1 12345678910111213141516class Solution(object): def missingNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums.sort() if len(nums) == 0 or nums[0] != 0: return 0 elif nums == [0]: return 1 else: for i in xrange(len(nums) - 1): if nums[i + 1] - nums[i] &gt; 1: return nums[i] + 1 return nums[-1] + 1","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"350. Intersection of Two Arrays II","date":"2017-03-07T12:26:00.000Z","path":"2017/03/07/intersection-of-two-arrays-ii/","text":"DescriptionDifficulty: Easy Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order. Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 求两个数组交集。 Solution鉴于结果的顺序不限，依然使用我最喜欢的字典类型来实现。（字典类型实际上是哈希表，因此效率喜人）将两个数组转化为字典：key：数组中元素value：元素出现次数然后根据较短的字典构建数组：每个在短数组出现过的元素，若在长数组中也存在，则在结果数组中添加数个该元素，添加的数量为该元素在两个字典中各自出现次数中较小的一个次数。 12345678910111213141516171819202122232425262728def to_set(nums): nums_set = &#123;&#125; for i in nums: try: nums_set[i] += 1 except KeyError: nums_set[i] = 1 return nums_setclass Solution(object): def intersect(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" nums1_set = to_set(nums1) nums2_set = to_set(nums2) intersection = [] if len(nums1_set) &gt; len(nums2_set): nums1_set, nums2_set = nums2_set, nums1_set # 1 &lt; 2 for j in nums1_set: if j in nums2_set: intersection = intersection + ([j] * min(nums1_set[j], nums2_set[j])) return intersection","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"13. Roman to Integer","date":"2017-03-07T11:46:00.000Z","path":"2017/03/07/roman-to-integer/","text":"DescriptionDifficulty: Easy Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 罗马数字转换为阿拉伯数字。 Solution一道很有趣的题。根据罗马数字左加右减的规则，在字符串长度大于 0 的情况下，每次取字符串第一个元素，若第一个元素是 IXC 其中一个且小于第二个元素，则总和加第二个元素减第一个元素，字符串修改为从第三个元素开始；若字符串长度为 1 或第一个元素不小于第二个元素，则总和加上第一个元素的值，字符串从第二个元素开始。返回总和。 123456789101112131415161718192021class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" dict = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; sum = 0 while len(s) &gt; 0: if len(s) == 1: sum += dict[s[0]] s = s[1:] elif dict[s[0]] &lt; dict[s[1]] and s[0] in 'IXC': sum += (dict[s[1]] - dict[s[0]]) s = s[2:] else: sum += dict[s[0]] s = s[1:] return sum","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"242. Valid Anagram","date":"2017-03-07T11:11:00.000Z","path":"2017/03/07/valid-anagram/","text":"DescriptionDifficulty: Easy Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? 判断两个词是不是同字母异构词。 Solution维护两个字典：key：字符串中的元素value：元素出现的次数 返回两个字典是否相等 1234567891011121314151617def add_to_set(str): xSet = &#123;&#125; for i in str: try: xSet[i] += 1 except KeyError: xSet[i] = 1 return xSetclass Solution(object): def isAnagram(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" return add_to_set(s) == add_to_set(t)","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"169. Majority Element","date":"2017-03-07T10:55:00.000Z","path":"2017/03/07/majority-element/","text":"DescriptionDifficulty: Easy Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 给一数列，找出众数。 Solution扫描一遍 nums，维护一个字典 xSet：key ：nums 中元素value：该元素出现次数再扫描一遍 xSet，找到出现次数大于 floor(len(nums)) 的元素，返回。 1234567891011121314151617import mathclass Solution(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" xSet = &#123;&#125; for i in nums: try: xSet[i] += 1 except KeyError: xSet[i] = 1 for j in xSet: if xSet[j] &gt; math.floor(len(nums) / 2): return j","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"171. Excel Sheet Column Number","date":"2017-03-06T17:04:00.000Z","path":"2017/03/07/excel-sheet-column-number/","text":"DescriptionDifficulty: Easy Given a column title as appear in an Excel sheet, return its corresponding column number. Example A -&gt; 1 B -&gt; 2 C -&gt; 3 … Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 将 Excel 中使用字母表示的列号转换为数字。 Solution26 进制转换为 10 进制。 1234567891011class Solution(object): def titleToNumber(self, s): \"\"\" :type s: str :rtype: int \"\"\" column = 0 s_r = s[::-1] for i in xrange(len(s_r)): column += ((26 ** i) * (ord(s_r[i]) - 64)) return column","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"122. Best Time to Buy and Sell Stock II","date":"2017-03-06T16:38:00.000Z","path":"2017/03/07/best-time-to-buy-and-sell-stock-ii/","text":"DescriptionDifficulty: Easy Say you have an array for which the i(th) element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 给出一个数列，第 i 个位置代表第 i 天的股价，求最大利润。隐含条件是每次买卖一股，本金不限。 Solution思路：炒股的思路很简单：高买低卖。本题等于有上帝视角，那么只需找出所有单调递增段，最低点买入最高点卖出即可。 定义变量：low：当前单调递增周期中低点；若位于单调递减周前则为 Nonehigh：当前单调递增周期中高点；profit：累计利润up：标记是否位于单调递增区间。 扫描一遍数列：开始时长度小于 3 的基本情况。 数列更大时：维护当前单调递增周期的 low 与 high；当前单调递增周期结束时（后一值小于前一值）结算一次利润，同时 up = False，low = None重新到达单调递增区间时重新设定 low 为低点。 123456789101112131415161718192021222324252627282930class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if len(prices) &lt;= 1: return 0 elif len(prices) == 2: return max(prices[1] - prices[0], 0) low = prices[0] high = prices[0] profit = 0 up = True for i in xrange(len(prices) - 1): if prices[i + 1] &gt;= prices[i]: # going up high = prices[i + 1] up = True if low == None: low = prices[i] elif prices[i + 1] &lt; prices[i]: if up == True: profit += (high - low) up = False low = None if up == True: profit += (high - low) return profit","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"387. First Unique Character in a String","date":"2017-03-06T16:07:00.000Z","path":"2017/03/07/first-unique-character-in-a-string/","text":"DescriptionDifficulty: Easy Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples = “leetcode”return 0. s = “loveleetcode”,return 2. NoteYou may assume the string contain only lowercase letters. 找到一个字符串中不重复的字符，返回其在字符串中位置，如不存在则返回 -1。 Solution思路：维护一个字典，键为字符串中各个字符，值为这样一个数组：[该字符出现次数, 该字符首次出现位置]。扫描一遍字符串，维护字典；扫描一遍字典，维护出现次数为 1 的最小位置，返回这个值。 1234567891011121314151617181920212223242526class Solution(object): def firstUniqChar(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) == 0: return -1 setX = &#123;&#125; for i in xrange(len(s)): try: setX[s[i]][0] += 1 # setX[s[i]][1] = min(setX[s[i]][1], i) except KeyError: setX[s[i]] = [1, i] # (count, first time position) # print(setX) posi = -1 for j in setX: if setX[j][0] == 1: if posi == -1: posi = setX[j][1] elif posi &gt; 0: posi = min(setX[j][1], posi) return posi","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"7. Reverse Integer","date":"2017-03-02T16:13:00.000Z","path":"2017/03/03/string-to-integer-atoi/","text":"DescriptionDifficulty: Medium Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Note: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. CheatSheetRequirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Solution123456789101112131415161718192021222324252627282930313233class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" str = str.strip() if str == '': return 0 neg = False nums = '0123456789' if str[0] == '-': neg = True str = str[1:] elif str[0] == '+': neg = False str = str[1:] if str == '' or str[0] not in nums: return 0 for i in xrange(len(str)): if str[i] not in nums: str = str[:i] break if str == '': return 0 if neg == False: return min(int(str), 2147483647) else: return max(-int(str), -2147483648)","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"283. Move Zeroes","date":"2017-02-28T14:07:00.000Z","path":"2017/02/28/move-zeroes/","text":"DescriptionDifficulty: Easy Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. 将数列中的所有 0 移到末尾，其他元素保持不变。要求原地执行 Solution设定工作指针初始为 0 位置，设定 tail 指针指向非 0 尾部。若工作指针指向元素为 0，则将该元素移动到 tail 位置，tail 前移一位；若工作指针指向元素非 0，工作指针后移一位，直至工作指针遇到 tail。实现如下： 123456789101112131415161718192021222324class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" # nums = moveZeroes_main(nums) length = len(nums) tail = length - 1 if length &gt; 1: for i in xrange(length-1, 0, -1): if nums[i] == 0: # if there are zeros at the end tail -= 1 else: break j = 0 while j &lt; tail: if nums[j] == 0: for k in xrange(j, tail): nums[k] = nums[k+1] nums[tail] = 0 tail -= 1 else: j += 1 最初考虑写一个递归的方法实现，每次讲末尾 0 和开头确定非 0 部分略去。但是 Python 的 list 每次切分时都会复制，因此不满足原地执行以及不使用 return 的要求。但是这个方法我很喜欢，无论如何还是附上 123456789101112131415def moveZeroes_main(nums): tail = len(nums) if tail &gt; 1: if nums[-1] == 0: # tail = len(''.join([str(i) for i in nums]).rstrip('0')) return moveZeroes_main(nums[:-1]) + [0] else: if nums[0] == 0: for j in xrange(1, tail): nums[j-1] = nums[j] nums[-1] = 0 return moveZeroes_main(nums) else: return [nums[0]] + moveZeroes_main(nums[1:tail]) return nums","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"463. Island Perimeter","date":"2017-02-26T17:35:00.000Z","path":"2017/02/27/island-perimeter/","text":"DescriptionDifficulty: Easy You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 找 1 组成的「岛」的边界。 Solution1 与 0 交替时、以及 1 元素越界时为边界。定义了一个方法，探测该位置是否为 0，或坐标包含负数，或数组越界。对 1 周围元素使用这个方法，这些情况边界长度加一。 12345678910111213141516171819202122232425262728def testSurround(grid, perimeter, x, y): if x &lt; 0 or y &lt; 0: perimeter += 1 else: try: z = grid[x][y] except IndexError: perimeter += 1 else: if z == 0: perimeter += 1 return perimeterclass Solution(object): def islandPerimeter(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" perimeter = 0 for i in xrange(len(grid)): for j in xrange(len(grid[i])): if grid[i][j] == 1: perimeter = testSurround(grid, perimeter, i, j - 1) perimeter = testSurround(grid, perimeter, i, j + 1) perimeter = testSurround(grid, perimeter, i - 1, j) perimeter = testSurround(grid, perimeter, i + 1, j) return perimeter","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"2. Add Two Numbers","date":"2017-02-24T16:01:00.000Z","path":"2017/02/25/add-two-numbers/","text":"DescriptionDifficulty: Easy You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solution实现一个低位到高位的加法运算。注意进位即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" l_r = ListNode(0) head = l_r plus1 = 0 while l1 != None or l2 != None: if plus1 == 0: l_n = ListNode(0) l_r.next = l_n l_r = l_n if l1 == None: l_r.val = l2.val + plus1 elif l2 == None: l_r.val = l1.val + plus1 else: l_r.val = l1.val + l2.val + plus1 plus1 = 0 if l_r.val &gt;= 10: plus1 = 1 l_r.val = l_r.val - 10 if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if plus1 == 1: l_n = ListNode(1) l_r.next = l_n l_r = l_n return head.next","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"3. Longest Substring Without Repeating Characters","date":"2017-02-23T04:19:24.000Z","path":"2017/02/23/longest-substring-without-repeating-characters/","text":"DescriptionDifficulty: Medium Given a string, find the length of the longest substring without repeating characters. Example1:Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution重点是字符串超长时的执行效率。 我使用的方法：一个指针指向 substring 最右端，作为工作指针不停向右；另一个指针初始指向字符串开头；遇到重复时指向字符串开头的指针向右移动一个，即 substring 去掉头部一个字符，再检测指向 substring 最右端的指针指向的字母是否重复。 这样实现仅需要遍历一遍整个字符串。 12345678910111213141516171819202122class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) &lt;= 1: return len(s) sub = '' max_l = 0 i = 0 while i &lt; len(s): if s[i] not in sub: sub += s[i] max_l = max(max_l, len(sub)) i += 1 else: sub = sub[1:] return max_l","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"7. Reverse Integer","date":"2017-02-22T16:05:30.000Z","path":"2017/02/23/reverse-integer/","text":"DescriptionDifficulty: Easy Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution123456789101112131415class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" x_s = str(x)[::-1] if x &lt; 0: x_s = '-' + x_s[:-1] if int(x_s) &gt; 2147483647 or int(x_s) &lt; -2147483648: return 0 else: return int(x_s)","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"1. Two Sum","date":"2017-02-22T10:43:48.000Z","path":"2017/02/22/two-sum/","text":"DescriptionDifficulty: Easy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution1234567891011class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j]","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"Hello World!","date":"2017-02-22T02:17:42.000Z","path":"2017/02/22/hello-world/","text":"终于有了一个足够强大的动机让我真正开始写博客。本博客的主要内容将是算法及其他编码的笔记，以及一些思考。","tags":[{"name":"thinking","slug":"thinking","permalink":"http://faramita.us/tags/thinking/"}]}]