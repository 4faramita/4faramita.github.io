{"meta":{"title":"之言片语","subtitle":null,"description":"Buried alive.","author":"4faramita","url":"http://faramita.us"},"pages":[],"posts":[{"title":"160. Intersection of Two Linked Lists","slug":"intersection-of-two-linked-lists","date":"2017-03-16T09:18:58.000Z","updated":"2017-03-16T09:20:53.000Z","comments":true,"path":"2017/03/16/intersection-of-two-linked-lists/","link":"","permalink":"http://faramita.us/2017/03/16/intersection-of-two-linked-lists/","excerpt":"","text":"DescriptionDifficulty: Easy Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 题意:两个链表，要求返回交叉点。 Solution先遍历一遍，确定二者的长度。从较长的一个开始遍历，直到二者长度相同，然后两个链表同时向后遍历，检测每一个点是不是点是不是相等1234567891011121314151617181920212223242526272829303132333435363738# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" pt_a, pt_b = headA, headB len_a, len_b = 0, 0 while pt_a: len_a += 1 pt_a = pt_a.next while pt_b: len_b += 1 pt_b = pt_b.next if len_a &gt; len_b: long, short = headA, headB else: long, short = headB, headA for diff in range(abs(len_a - len_b)): long = long.next common = None while long: if long == short: common = long break else: long, short = long.next, short.next return common","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"14. Longest Common Prefix","slug":"longest-common-prefix","date":"2017-03-16T09:02:11.000Z","updated":"2017-03-16T09:05:15.000Z","comments":true,"path":"2017/03/16/longest-common-prefix/","link":"","permalink":"http://faramita.us/2017/03/16/longest-common-prefix/","excerpt":"","text":"DescriptionDifficulty: Easy Write a function to find the longest common prefix string amongst an array of strings. 题意:给出一 list，内容为一些字符串，找出这些字符串的最长公共前缀。 Solution先将前缀 prefix 定位 list 的第一个元素。对于之后的每一个元素，如果该元素比 prefix 短，则先将 prefix 切成相应长度。然后对比 prefix 与当前元素，遇到不同则将 prefix 切成不同点之前的部分。 12345678910111213141516171819202122232425class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if strs == []: return '' elif len(strs) == 1: return strs[0] prefix = strs[0] for s in strs[1:]: if s == '' or prefix == '': return '' prefix = prefix[:min(len(prefix), len(s))] for posi in range(len(prefix)): if prefix[posi] != s[posi]: prefix = prefix[:posi] break if len(prefix) == 0: return '' return prefix","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"88. Merge Sorted Array","slug":"merge-sorted-array","date":"2017-03-16T08:31:03.000Z","updated":"2017-03-16T08:34:38.000Z","comments":true,"path":"2017/03/16/merge-sorted-array/","link":"","permalink":"http://faramita.us/2017/03/16/merge-sorted-array/","excerpt":"","text":"DescriptionDifficulty: Easy Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 题意:给两个有序数组 nums1、nums2，将两个数组原地合并到 nums1，保持 nums1 有序。 Solution与归并排序类似，但是从头部开始归并的成本太高，而 nums1 又有足够的长度，因此从两数组的尾部开始归并，放在 nums1 尾部（从 m + n - 1 开始）。 1234567891011121314151617181920212223242526class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" if n == 0: return p1, p2 = m - 1, n - 1 # 2 working pointers init at the ends for i in range(m + n - 1, -1, -1): if p1 &lt; 0: nums1[i] = nums2[p2] p2 -= 1 elif p2 &lt; 0: nums1[i] = nums1[p1] p1 -= 1 elif nums1[p1] &gt; nums2[p2]: nums1[i] = nums1[p1] p1 -= 1 elif nums1[p1] &lt;= nums2[p2]: nums1[i] = nums2[p2] p2 -= 1","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"234. Palindrome Linked List","slug":"palindrome-linked-list","date":"2017-03-14T08:18:22.000Z","updated":"2017-03-14T08:20:39.000Z","comments":true,"path":"2017/03/14/palindrome-linked-list/","link":"","permalink":"http://faramita.us/2017/03/14/palindrome-linked-list/","excerpt":"","text":"DescriptionDifficulty: Easy Given a singly linked list, determine if it is a palindrome. Follow up:Could you do it in O(n) time and O(1) space? 题意:判断一个链表是否回文。 Solution最简单的想法是把链表的值按顺序输出到一个数组，在判断数组是否回文；判断数组是否回文，也就是判断前一半的逆序是否与后一半相等。 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if not head: return True link_list = [] p = head while p: link_list.append(p.val) p = p.next length = len(link_list) if length % 2 == 0: return link_list[:(length / 2)] == link_list[(length / 2):][::-1] else: return link_list[:(length / 2)] == link_list[(length / 2) + 1:][::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"412. Fizz Buzz","slug":"fizz-buzz","date":"2017-03-14T07:38:00.000Z","updated":"2017-03-14T07:38:35.000Z","comments":true,"path":"2017/03/14/fizz-buzz/","link":"","permalink":"http://faramita.us/2017/03/14/fizz-buzz/","excerpt":"","text":"DescriptionDifficulty: Easy Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Examplen = 15, Return:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] Solution123456789101112131415161718class Solution(object): def fizzBuzz(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" rslt = [] for i in xrange(n): if (i + 1) % 15 == 0: rslt.append('FizzBuzz') elif (i + 1) % 5 == 0: rslt.append('Buzz') elif (i + 1) % 3 == 0: rslt.append('Fizz') else: rslt.append(str(i + 1)) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"20. Valid Parentheses","slug":"valid-parentheses","date":"2017-03-14T06:35:45.000Z","updated":"2017-03-14T06:41:31.000Z","comments":true,"path":"2017/03/14/valid-parentheses/","link":"","permalink":"http://faramita.us/2017/03/14/valid-parentheses/","excerpt":"","text":"DescriptionDifficulty: Easy Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 题意:输入一列括号组合，数出是否合法，即括号是否先打开后关闭并且以正确顺序关闭。 Solution实际上就是实现一个 stack。这里使用 dict 类型来判断左右括号是否对应。 123456789101112131415161718192021222324class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" left = &#123;'(': 0, '[': 1, '&#123;': 2&#125; # left dict right = &#123;')': 0, ']': 1, '&#125;': 2&#125; # right dict stack = [] # working stack for i in s: # every element in s if i in left: # if it's one of the lefts stack.append(i) # stack push elif i in right: # if it's one of the rights try: # try to pop tmp = stack.pop() except IndexError: # if nothing to pop, return False return False if left[tmp] != right[i]: # if they do not match, return False return False if stack == []: # stack must be empty return True else: return False","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"38. Count and Say","slug":"count-and-say","date":"2017-03-14T06:23:48.000Z","updated":"2017-03-14T06:26:36.000Z","comments":true,"path":"2017/03/14/count-and-say/","link":"","permalink":"http://faramita.us/2017/03/14/count-and-say/","excerpt":"","text":"DescriptionDifficulty: Easy The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, … 1 is read off as “one 1” or 11.11 is read off as “two 1s” or 21.21 is read off as “one 2, then one 1” or 1211. Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. 题意:有这样一个数列，下一个元素是由上一个元素按照（元素个数，元素）的方法组成的。求这个数列的第 n 个元素。 Solution迭代：把数列的上一个元素在元素变化的点切分，然后数出每一块的长度即可。_loop 函数用来迭代。 1234567891011121314151617181920212223242526272829303132333435def _loop(s): if len(s) == 1: return '11' head, tail = 1, 0 rslt = [] rslt_s = '' scanning = False while max(head, tail) &lt; len(s): if s[head] == s[tail] and not scanning: scanning = True elif s[head] != s[tail]: rslt.append(s[tail:head]) tail = head if scanning: scanning = False head += 1 # if scanning: rslt.append(s[tail:]) for sub in rslt: rslt_s = rslt_s + str(len(sub)) + sub[0] return rslt_sclass Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" rslt = '1' for i in range(1, n): rslt = _loop(rslt) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"172. Factorial Trailing Zeroes","slug":"factorial-trailing-zeroes","date":"2017-03-14T04:47:28.000Z","updated":"2017-03-14T04:50:04.000Z","comments":true,"path":"2017/03/14/factorial-trailing-zeroes/","link":"","permalink":"http://faramita.us/2017/03/14/factorial-trailing-zeroes/","excerpt":"","text":"DescriptionDifficulty: Easy Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 题意:数输入数字的阶乘的末尾由多少个 0。 Solution每个 0 都是由 2 * 5 提供的。但是由于 偶数众多，因此 2 总是足够的；同时有些数字中包含多个 5（如 25），故需要多次重复直到数字中不含 5。 1234567891011class Solution(object): def trailingZeroes(self, n): \"\"\" :type n: int :rtype: int \"\"\" zeros = 0 while n &gt; 0: n /= 5 zeros += n return zeros","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"4. Median of Two Sorted Arrays","slug":"median-of-two-sorted-arrays","date":"2017-03-14T03:28:00.000Z","updated":"2017-03-14T07:39:51.000Z","comments":true,"path":"2017/03/14/median-of-two-sorted-arrays/","link":"","permalink":"http://faramita.us/2017/03/14/median-of-two-sorted-arrays/","excerpt":"","text":"DescriptionDifficulty: Hard There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example1nums1 = [1, 3]nums2 = [2] The median is 2.0 Example2nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 给出两个有序数列，返回两个数列形成的大数列的中位数。 Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" # pointers for two lists p1 = 0 p2 = 0 isOdd = True # last nums last = 0 if (len(nums1) + len (nums2)) % 2 == 1: exp_num = (len(nums1) + len (nums2) + 1) / 2 isOdd = True else: exp_num = ((len(nums1) + len (nums2)) / 2) + 1 isOdd = False if len(nums1) == 0 or len(nums2) == 0: comb = nums1 + nums2 if isOdd == True: return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) elif nums1[-1] &lt;= nums2[0]: comb = nums1 + nums2 if isOdd == True: return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) elif nums2[-1] &lt;= nums1[0]: comb = nums2 + nums1 if isOdd == True: print(comb[exp_num]) return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) while p1 + p2 &lt;= exp_num - 2: if p1 &gt;= len(nums1): last = nums2[p2] p2 += 1 elif p2 &gt;= len(nums2): last = nums1[p1] p1 += 1 elif nums1[p1] &lt; nums2[p2]: last = nums1[p1] p1 += 1 else: last = nums2[p2] p2 += 1 if p1 &gt;= len(nums1): toAdd = nums2[p2] elif p2 &gt;= len(nums2): toAdd = nums1[p1] else: toAdd = min(nums1[p1], nums2[p2]) if isOdd == True: return toAdd else: return (toAdd + last) / float(2)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"136. Single Number","slug":"single-number","date":"2017-03-14T03:28:00.000Z","updated":"2017-03-14T07:41:50.000Z","comments":true,"path":"2017/03/14/single-number/","link":"","permalink":"http://faramita.us/2017/03/14/single-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 给出一个整数数组，有一个元素只出现了一次，其他所有元素都出现了两次。找出这个元素。 Solution123456789101112131415class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" rslt = &#123;&#125; for i in nums: try: rslt[i] += 1 except KeyError: rslt[i] = 1 for j in rslt: if rslt[j] == 1: return j","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"344. Reverse String","slug":"reverse-string","date":"2017-03-14T03:28:00.000Z","updated":"2017-03-14T07:40:34.000Z","comments":true,"path":"2017/03/14/reverse-string/","link":"","permalink":"http://faramita.us/2017/03/14/reverse-string/","excerpt":"","text":"DescriptionDifficulty: Easy Write a function that takes a string as input and returns the string reversed. Example1Given s = “hello”, return “olleh”. 反转字符串。 Solution1234567class Solution(object): def reverseString(self, s): \"\"\" :type s: str :rtype: str \"\"\" return s[::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"26. Remove Duplicates from Sorted Array","slug":"remove-duplicates-from-sorted-array","date":"2017-03-13T17:09:00.000Z","updated":"2017-03-14T02:39:32.000Z","comments":true,"path":"2017/03/14/remove-duplicates-from-sorted-array/","link":"","permalink":"http://faramita.us/2017/03/14/remove-duplicates-from-sorted-array/","excerpt":"","text":"DescriptionDifficulty: Easy Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 题意:原地为一个数组去重，返回不重复的数组长度 n 并且仅需保持该数组前 n 位为不重复的数组。 Solution虽然效率偏低，但是重复的删掉就好。 123456789101112131415161718192021222324class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt;= 1: return len(nums) elif len(nums) == 2: if nums[0] == nums[1]: return 1 else: return 2 # now,it has at least the length of 3 i = 1 while i &lt; len(nums): # if nums[tail] != nums[i]: # tail += 1 if nums[i-1] == nums[i]: del(nums[i]) else: i += 1 return len(nums) update：讨论中展示了一种简洁而优美的写法：123456789101112131415class Solution: # @param a list of integers # @return an integer def removeDuplicates(self, A): if not A: return 0 newTail = 0 for i in range(1, len(A)): if A[i] != A[newTail]: newTail += 1 A[newTail] = A[i] return newTail + 1 也就是将每一个不同的元素复制到 newTail 位置。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"118. Pascal's Triangle","slug":"pascals-triangle","date":"2017-03-13T15:31:29.000Z","updated":"2017-03-13T15:32:54.000Z","comments":true,"path":"2017/03/13/pascals-triangle/","link":"","permalink":"http://faramita.us/2017/03/13/pascals-triangle/","excerpt":"","text":"DescriptionDifficulty: Easy Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题意:给出行数，生成相应行帕斯卡三角。 Solution帕斯卡三角的下一行的某元素是上一行的相邻两元素的和。 123456789101112131415161718192021class Solution(object): def generate(self, numRows): \"\"\" :type numRows: int :rtype: List[List[int]] \"\"\" if numRows == 0: rslt = [] elif numRows == 1: rslt = [[1]] elif numRows == 2: rslt = [[1], [1, 1]] elif numRows &gt; 2: rslt = [[1], [1, 1]] for i in xrange(2, numRows): now = [1] for j in xrange(1, i): now.append(rslt[i-1][j-1] + rslt[i-1][j]) now.append(1) rslt.append(now) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"66. Plus One","slug":"plus-one","date":"2017-03-13T15:13:18.000Z","updated":"2017-03-14T02:35:13.000Z","comments":true,"path":"2017/03/13/plus-one/","link":"","permalink":"http://faramita.us/2017/03/13/plus-one/","excerpt":"","text":"DescriptionDifficulty: Easy Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. 题意:给一个数组，每个元素表示一个数字的每一位，要求以相同形式给出这个数字加一的结果。 Solution难点在于进位，特别是由 n 位数变为 n + 1 位数时，如果每一位都移动代价太太。这里先将数组逆置，然后从头部（即末位）加一，进位完成后在逆置回来。 123456789101112131415161718class Solution(object): def plusOne(self, digits): \"\"\" :type digits: List[int] :rtype: List[int] \"\"\" digits_r = digits[::-1] added = False for i in xrange(len(digits)): if digits_r[i] + 1 &lt; 10: digits_r[i] += 1 added = True break elif digits_r[i] + 1 == 10: digits_r[i] = 0 if added == False: digits_r.append(1) return digits_r[::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"一个交作业的小工具 v2.1","slug":"a-tool-for-homework-v2.1","date":"2017-03-13T11:40:32.000Z","updated":"2017-03-13T11:43:39.000Z","comments":true,"path":"2017/03/13/a-tool-for-homework-v2.1/","link":"","permalink":"http://faramita.us/2017/03/13/a-tool-for-homework-v2.1/","excerpt":"","text":"update:网页结构稍有变化，修改以适应；文件名获取方式更加可靠。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: UTF-8 -*-import sysimport timefrom pyquery import PyQuery as pqtmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**&#123;contents&#125;&lt;b&gt;题意:&lt;/b&gt;&lt;br&gt;## Solution&#123;% codeblock lang:text %&#125;&#123;% endcodeblock %&#125;'''url = sys.argv[1]d = pq(url)get_title = d('.question-title h3').text()get_difficulty = d('.question-info li strong').eq(2).text()get_filename = url.lstrip('https://').split('/')[2] + '.md'get_contents = (d('.question-content').html(method='html') .split('&lt;p&gt;&lt;a href=\"/subscribe/\"&gt;Subscribe&lt;/a&gt;')[0].rstrip().rstrip('&lt;div&gt;') .split('&lt;p&gt;&lt;b&gt;Credits:&lt;/b&gt;')[0].strip())tmp = tmp.format( title=get_title, difficulty=get_difficulty, contents=get_contents, date=time.strftime(\"%F %H:%M:%S\", time.localtime()))file = open(get_filename, 'w')file.write(tmp)file.close()# call(['vim', get_filename])print('Show time:\\n', get_filename) 人生苦短，我用 Python。","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"101. Symmetric Tree","slug":"symmetric-tree","date":"2017-03-13T11:20:39.000Z","updated":"2017-03-13T15:16:25.000Z","comments":true,"path":"2017/03/13/symmetric-tree/","link":"","permalink":"http://faramita.us/2017/03/13/symmetric-tree/","excerpt":"","text":"DescriptionDifficulty: Easy Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3Note:Bonus points if you could solve it both recursively and iteratively. 题意：输入一棵二叉树，判断是否纵向轴对称（与镜像相同）。 Solution只需要判断跟节点的左右子树是否镜像对称。也就是说只需要判断右子树翻转后是否与左子树相同即可。也就是以相同方式遍历左子树与翻转后的右子树，生成的值的数组相同即可。 方法 revrs_bt 用于反转二叉树；方法 mlr_walk 用于前序遍历二叉树；返回生成的两数组是否相等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Nonedef revrs_bt(node): head = node if node: node.left, node.right = revrs_bt(node.right), revrs_bt(node.left) return headdef mlr_walk(rslt, node): if node: rslt.append(node.val) try: mlr_walk(rslt, node.left) except AttributeError: rslt.append(None) try: mlr_walk(rslt, node.right) except AttributeError: rslt.append(None) return rsltclass Solution(object): def isSymmetric(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" if root == None or (root.left, root.right) == (None, None): return True t_l = root.left # left tree t_r = root.right # right tree t_r_r = revrs_bt(t_r) # reversed right tree rslt_l, rslt_r = [], [] rslt_l = mlr_walk(rslt_l, t_l) rslt_r = mlr_walk(rslt_r, t_r_r) return rslt_l == rslt_r","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"198. House Robber","slug":"house-robber","date":"2017-03-13T04:30:07.000Z","updated":"2017-03-13T04:41:54.000Z","comments":true,"path":"2017/03/13/house-robber/","link":"","permalink":"http://faramita.us/2017/03/13/house-robber/","excerpt":"","text":"DescriptionDifficulty: Easy You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 一个数组，每个元素是这家藏的钱，不能连续抢两家的钱，要求抢到尽量多的钱，求能抢到的最多的钱数。 Solution又一道动态规划的问题，当数组遍历至 i 位置时，pre2 表示 i - 2 位置的和, pre1 表示 i - 1 位置的和, curr 用于保存本轮结果。对于每个 i（i &gt; 3）都要做出这样一个选择：要 pre2 + nums[i] 还是要 pre1. 123456789101112131415161718192021class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) prev1,prev2,curr = 0, 0, 0 for i in nums: curr = max(i + prev2, prev1); prev2 = prev1; prev1 = curr; return curr","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"70. Climbing Stairs","slug":"climbing-stairs","date":"2017-03-10T02:00:59.000Z","updated":"2017-03-10T02:04:56.000Z","comments":true,"path":"2017/03/10/climbing-stairs/","link":"","permalink":"http://faramita.us/2017/03/10/climbing-stairs/","excerpt":"","text":"DescriptionDifficulty: Easy You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. n 阶楼梯，每次可以爬一阶或者两阶，问有多少种方法。 Solution由于包含动态规划的两个特征： 最优子结构 重复的子问题 因此可用动态规划。 核心算法：为了到达第 i 阶（i &gt;= 3)，可以从 i - 1 阶上一阶，也可以从 i - 2 阶上两阶。递归这个算法即可。 1234567891011class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\" stor = &#123;1: 1, 2: 2&#125; for i in xrange(3, n+1): stor[i] = stor[i-1] + stor[i-2] return stor[n]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"一个交作业的小工具 v2.0","slug":"a-tool-for-homework-v2","date":"2017-03-08T13:32:32.000Z","updated":"2017-03-12T06:05:59.000Z","comments":true,"path":"2017/03/08/a-tool-for-homework-v2/","link":"","permalink":"http://faramita.us/2017/03/08/a-tool-for-homework-v2/","excerpt":"","text":"本版将参数减少到一个：题目的 URL。之后自动获取文件名、标题、描述、难度等等，只需填写题目解释、解题思路与代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/python# -*- coding: UTF-8 -*-import sysimport timefrom pyquery import PyQuery as pqtmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**&#123;contents&#125;## Solution&#123;% codeblock lang:text %&#125;&#123;% endcodeblock %&#125;'''url = sys.argv[1]d = pq(url)get_title = d('.question-title h3').text()get_difficulty = d('#DescriptionContent .question-info li strong').eq(2).text()get_filename = url.rstrip('?tab=Description').rstrip('/').split('/')[-1] + '.md'get_contents = (d('.question-content') .html(method='html') .split('&lt;div&gt;&lt;p&gt;&lt;a href=\"/subscribe/\"&gt;Subscribe&lt;/a&gt;')[0] .split('&lt;p&gt;&lt;b&gt;Credits:&lt;/b&gt;')[0] .strip())tmp = tmp.format( title=get_title, difficulty=get_difficulty, contents=get_contents, date=time.strftime(\"%F %H:%M:%S\", time.localtime()))file = open(get_filename, 'w')file.write(tmp)file.close()print('Show time:', get_filename) 下一版打算实现输入题号代替网址。 人生苦短，我用 Python。","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"202. Happy Number","slug":"happy-number","date":"2017-03-08T13:27:07.000Z","updated":"2017-03-08T13:35:01.000Z","comments":true,"path":"2017/03/08/happy-number/","link":"","permalink":"http://faramita.us/2017/03/08/happy-number/","excerpt":"","text":"DescriptionDifficulty: Easy Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 返回输入数字是否是「快乐数」，即重复计算各位数字平方和，如果最终等于 1 则「快乐」。 Solution递归运算，直到算出一位数结果。一位数中只有 1，7 满足条件。为了减少计算量，直接删去数字中的 0。 1234567891011121314151617181920212223242526def happy(n): if n &lt;= 0: return False sum = 0 if n &lt;= 10: if n == 1 or n == 7 or n == 10: return True else: return False # return False elif n &gt; 10: s = str(n).strip('0') for i in s: sum += (int(i) ** 2) return happy(sum)class Solution(object): def isHappy(self, n): \"\"\" :type n: int :rtype: bool \"\"\" return happy(n)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"一个交作业的小工具","slug":"a-tool-for-homework","date":"2017-03-08T08:58:32.000Z","updated":"2017-03-12T06:05:46.000Z","comments":true,"path":"2017/03/08/a-tool-for-homework/","link":"","permalink":"http://faramita.us/2017/03/08/a-tool-for-homework/","excerpt":"","text":"本博客基于 Hexo 搭建。Hexo 的文章格式虽然简单，但是每次手打也实在太麻烦。故写一小脚本帮助生成需要的作业格式。三个参数分别为文件名，标题与难度；除此以外还会自动填充当前时间。代码如下。 12345678910111213141516171819202122232425262728293031#!/usr/bin/python3# -*- coding: UTF-8 -*-import sysimport timetmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**## Solution'''tmp = tmp.format( title=sys.argv[2], difficulty=sys.argv[3], date=time.strftime(\"%F %H:%M:%S\", time.localtime()))tmp += (r'&#123;% codeblock lang:python %&#125;' + '\\n\\n' + r'&#123;% endcodeblock %&#125;' + '\\n')file = open(sys.argv[1] + '.md', 'w')file.write(tmp)file.close()print(sys.argv[1] + '.md') 之后还会对信息填充进一步优化，如从网页自动获取问题描述等。 人生苦短，我用 Python。","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"121. Best Time to Buy and Sell Stock","slug":"best-time-to-buy-and-sell-stock","date":"2017-03-08T08:51:32.000Z","updated":"2017-03-08T08:56:32.000Z","comments":true,"path":"2017/03/08/best-time-to-buy-and-sell-stock/","link":"","permalink":"http://faramita.us/2017/03/08/best-time-to-buy-and-sell-stock/","excerpt":"","text":"DescriptionDifficulty: Easy Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. 给出一数组，代表每天的股价。要求只能买卖一次，求最大利润。 Solution实际上是求数组中后面的数与前面的数的最大差值。最简单的方法自然是两个循环，但是时间复杂度为 O(n^2)，很不理想。 思路：由于在每个单调区间中对答案有意义的元素只有区间两端的值而已。因此构建两个新数组，分别只包含每个单调区间的最大值与最小值。之后，针对最小值数组中每个元素，找最大值数组相应位置及之后的最大元素即可算出最大差值（利润） 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" max_profit = 0 if len(prices) == 2: return max(prices[1] - prices[0], 0) elif len(prices) &gt; 2: low = prices[0] high = prices[0] profit = 0 list_low = [prices[0]] list_high = [] up = True for i in xrange(len(prices) - 1): if prices[i + 1] &gt;= prices[i]: # going up high = prices[i + 1] if up == False: low = prices[i] list_low.append(low) up = True elif prices[i + 1] &lt; prices[i]: # going down low = prices[i + 1] if up == True: high = prices[i] list_high.append(high) up = False if len(list_high) &lt; len(list_low): list_high.append(prices[-1]) for j in xrange(len(list_low)): max_profit = max(max_profit, max(list_high[j:]) - list_low[j]) return max_profit","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"","slug":"sdsdsd","date":"2017-03-08T08:02:24.000Z","updated":"2017-03-08T08:03:21.000Z","comments":true,"path":"2017/03/08/sdsdsd/","link":"","permalink":"http://faramita.us/2017/03/08/sdsdsd/","excerpt":"","text":"example.md","categories":[],"tags":[]},{"title":"268. Missing Number","slug":"missing-number","date":"2017-03-07T12:46:00.000Z","updated":"2017-03-07T12:51:23.000Z","comments":true,"path":"2017/03/07/missing-number/","link":"","permalink":"http://faramita.us/2017/03/07/missing-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example,Given nums = [0, 1, 3] return 2. Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 给一数组，给出数组与 [0,1,2,3,4,…,n] 相比缺少的一个数。所给数组可为任意顺序。 Solution先排序。分析一下情况：数组长度为 0：缺 1数组长度为 1：有两种情况（因为只能缺一个数）[0], [1]；分别返回 1, 0数组更长：若第一个元素不是 0，则返回 0；设两个指针从开头遍历，若后一个减前一个大于 1，则返回前一个 + 1；若一直连续，这返回最后一个元素 + 1 12345678910111213141516class Solution(object): def missingNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums.sort() if len(nums) == 0 or nums[0] != 0: return 0 elif nums == [0]: return 1 else: for i in xrange(len(nums) - 1): if nums[i + 1] - nums[i] &gt; 1: return nums[i] + 1 return nums[-1] + 1","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"350. Intersection of Two Arrays II","slug":"intersection-of-two-arrays-ii","date":"2017-03-07T12:26:00.000Z","updated":"2017-03-07T12:33:13.000Z","comments":true,"path":"2017/03/07/intersection-of-two-arrays-ii/","link":"","permalink":"http://faramita.us/2017/03/07/intersection-of-two-arrays-ii/","excerpt":"","text":"DescriptionDifficulty: Easy Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order. Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 求两个数组交集。 Solution鉴于结果的顺序不限，依然使用我最喜欢的字典类型来实现。（字典类型实际上是哈希表，因此效率喜人）将两个数组转化为字典：key：数组中元素value：元素出现次数然后根据较短的字典构建数组：每个在短数组出现过的元素，若在长数组中也存在，则在结果数组中添加数个该元素，添加的数量为该元素在两个字典中各自出现次数中较小的一个次数。 12345678910111213141516171819202122232425262728def to_set(nums): nums_set = &#123;&#125; for i in nums: try: nums_set[i] += 1 except KeyError: nums_set[i] = 1 return nums_setclass Solution(object): def intersect(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" nums1_set = to_set(nums1) nums2_set = to_set(nums2) intersection = [] if len(nums1_set) &gt; len(nums2_set): nums1_set, nums2_set = nums2_set, nums1_set # 1 &lt; 2 for j in nums1_set: if j in nums2_set: intersection = intersection + ([j] * min(nums1_set[j], nums2_set[j])) return intersection","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"13. Roman to Integer","slug":"roman-to-integer","date":"2017-03-07T11:46:00.000Z","updated":"2017-03-07T11:51:39.000Z","comments":true,"path":"2017/03/07/roman-to-integer/","link":"","permalink":"http://faramita.us/2017/03/07/roman-to-integer/","excerpt":"","text":"DescriptionDifficulty: Easy Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 罗马数字转换为阿拉伯数字。 Solution一道很有趣的题。根据罗马数字左加右减的规则，在字符串长度大于 0 的情况下，每次取字符串第一个元素，若第一个元素是 IXC 其中一个且小于第二个元素，则总和加第二个元素减第一个元素，字符串修改为从第三个元素开始；若字符串长度为 1 或第一个元素不小于第二个元素，则总和加上第一个元素的值，字符串从第二个元素开始。返回总和。 123456789101112131415161718192021class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" dict = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; sum = 0 while len(s) &gt; 0: if len(s) == 1: sum += dict[s[0]] s = s[1:] elif dict[s[0]] &lt; dict[s[1]] and s[0] in 'IXC': sum += (dict[s[1]] - dict[s[0]]) s = s[2:] else: sum += dict[s[0]] s = s[1:] return sum","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"242. Valid Anagram","slug":"valid-anagram","date":"2017-03-07T11:11:00.000Z","updated":"2017-03-07T11:13:12.000Z","comments":true,"path":"2017/03/07/valid-anagram/","link":"","permalink":"http://faramita.us/2017/03/07/valid-anagram/","excerpt":"","text":"DescriptionDifficulty: Easy Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? 判断两个词是不是同字母异构词。 Solution维护两个字典：key：字符串中的元素value：元素出现的次数 返回两个字典是否相等 1234567891011121314151617def add_to_set(str): xSet = &#123;&#125; for i in str: try: xSet[i] += 1 except KeyError: xSet[i] = 1 return xSetclass Solution(object): def isAnagram(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" return add_to_set(s) == add_to_set(t)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"169. Majority Element","slug":"majority-element","date":"2017-03-07T10:55:00.000Z","updated":"2017-03-07T10:58:04.000Z","comments":true,"path":"2017/03/07/majority-element/","link":"","permalink":"http://faramita.us/2017/03/07/majority-element/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 给一数列，找出众数。 Solution扫描一遍 nums，维护一个字典 xSet：key ：nums 中元素value：该元素出现次数再扫描一遍 xSet，找到出现次数大于 floor(len(nums)) 的元素，返回。 1234567891011121314151617import mathclass Solution(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" xSet = &#123;&#125; for i in nums: try: xSet[i] += 1 except KeyError: xSet[i] = 1 for j in xSet: if xSet[j] &gt; math.floor(len(nums) / 2): return j","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"171. Excel Sheet Column Number","slug":"excel-sheet-column-number","date":"2017-03-06T17:04:00.000Z","updated":"2017-03-06T17:05:51.000Z","comments":true,"path":"2017/03/07/excel-sheet-column-number/","link":"","permalink":"http://faramita.us/2017/03/07/excel-sheet-column-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given a column title as appear in an Excel sheet, return its corresponding column number. Example A -&gt; 1 B -&gt; 2 C -&gt; 3 … Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 将 Excel 中使用字母表示的列号转换为数字。 Solution26 进制转换为 10 进制。 1234567891011class Solution(object): def titleToNumber(self, s): \"\"\" :type s: str :rtype: int \"\"\" column = 0 s_r = s[::-1] for i in xrange(len(s_r)): column += ((26 ** i) * (ord(s_r[i]) - 64)) return column","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"122. Best Time to Buy and Sell Stock II","slug":"best-time-to-buy-and-sell-stock-ii","date":"2017-03-06T16:38:00.000Z","updated":"2017-03-08T07:09:28.000Z","comments":true,"path":"2017/03/07/best-time-to-buy-and-sell-stock-ii/","link":"","permalink":"http://faramita.us/2017/03/07/best-time-to-buy-and-sell-stock-ii/","excerpt":"","text":"DescriptionDifficulty: Easy Say you have an array for which the i(th) element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 给出一个数列，第 i 个位置代表第 i 天的股价，求最大利润。隐含条件是每次买卖一股，本金不限。 Solution思路：炒股的思路很简单：高买低卖。本题等于有上帝视角，那么只需找出所有单调递增段，最低点买入最高点卖出即可。 定义变量：low：当前单调递增周期中低点；若位于单调递减周前则为 Nonehigh：当前单调递增周期中高点；profit：累计利润up：标记是否位于单调递增区间。 扫描一遍数列：开始时长度小于 3 的基本情况。 数列更大时：维护当前单调递增周期的 low 与 high；当前单调递增周期结束时（后一值小于前一值）结算一次利润，同时 up = False，low = None重新到达单调递增区间时重新设定 low 为低点。 123456789101112131415161718192021222324252627282930class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if len(prices) &lt;= 1: return 0 elif len(prices) == 2: return max(prices[1] - prices[0], 0) low = prices[0] high = prices[0] profit = 0 up = True for i in xrange(len(prices) - 1): if prices[i + 1] &gt;= prices[i]: # going up high = prices[i + 1] up = True if low == None: low = prices[i] elif prices[i + 1] &lt; prices[i]: if up == True: profit += (high - low) up = False low = None if up == True: profit += (high - low) return profit","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"387. First Unique Character in a String","slug":"first-unique-character-in-a-string","date":"2017-03-06T16:07:00.000Z","updated":"2017-03-06T16:38:37.000Z","comments":true,"path":"2017/03/07/first-unique-character-in-a-string/","link":"","permalink":"http://faramita.us/2017/03/07/first-unique-character-in-a-string/","excerpt":"","text":"DescriptionDifficulty: Easy Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples = “leetcode”return 0. s = “loveleetcode”,return 2. NoteYou may assume the string contain only lowercase letters. 找到一个字符串中不重复的字符，返回其在字符串中位置，如不存在则返回 -1。 Solution思路：维护一个字典，键为字符串中各个字符，值为这样一个数组：[该字符出现次数, 该字符首次出现位置]。扫描一遍字符串，维护字典；扫描一遍字典，维护出现次数为 1 的最小位置，返回这个值。 1234567891011121314151617181920212223242526class Solution(object): def firstUniqChar(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) == 0: return -1 setX = &#123;&#125; for i in xrange(len(s)): try: setX[s[i]][0] += 1 # setX[s[i]][1] = min(setX[s[i]][1], i) except KeyError: setX[s[i]] = [1, i] # (count, first time position) # print(setX) posi = -1 for j in setX: if setX[j][0] == 1: if posi == -1: posi = setX[j][1] elif posi &gt; 0: posi = min(setX[j][1], posi) return posi","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"7. Reverse Integer","slug":"string-to-integer-atoi","date":"2017-03-02T16:13:00.000Z","updated":"2017-03-02T16:13:56.000Z","comments":true,"path":"2017/03/03/string-to-integer-atoi/","link":"","permalink":"http://faramita.us/2017/03/03/string-to-integer-atoi/","excerpt":"","text":"DescriptionDifficulty: Medium Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Note: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. CheatSheetRequirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Solution123456789101112131415161718192021222324252627282930313233class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" str = str.strip() if str == '': return 0 neg = False nums = '0123456789' if str[0] == '-': neg = True str = str[1:] elif str[0] == '+': neg = False str = str[1:] if str == '' or str[0] not in nums: return 0 for i in xrange(len(str)): if str[i] not in nums: str = str[:i] break if str == '': return 0 if neg == False: return min(int(str), 2147483647) else: return max(-int(str), -2147483648)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"283. Move Zeroes","slug":"move-zeroes","date":"2017-02-28T14:07:00.000Z","updated":"2017-02-28T14:15:24.000Z","comments":true,"path":"2017/02/28/move-zeroes/","link":"","permalink":"http://faramita.us/2017/02/28/move-zeroes/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. 将数列中的所有 0 移到末尾，其他元素保持不变。要求原地执行 Solution设定工作指针初始为 0 位置，设定 tail 指针指向非 0 尾部。若工作指针指向元素为 0，则将该元素移动到 tail 位置，tail 前移一位；若工作指针指向元素非 0，工作指针后移一位，直至工作指针遇到 tail。实现如下： 123456789101112131415161718192021222324class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" # nums = moveZeroes_main(nums) length = len(nums) tail = length - 1 if length &gt; 1: for i in xrange(length-1, 0, -1): if nums[i] == 0: # if there are zeros at the end tail -= 1 else: break j = 0 while j &lt; tail: if nums[j] == 0: for k in xrange(j, tail): nums[k] = nums[k+1] nums[tail] = 0 tail -= 1 else: j += 1 最初考虑写一个递归的方法实现，每次讲末尾 0 和开头确定非 0 部分略去。但是 Python 的 list 每次切分时都会复制，因此不满足原地执行以及不使用 return 的要求。但是这个方法我很喜欢，无论如何还是附上 123456789101112131415def moveZeroes_main(nums): tail = len(nums) if tail &gt; 1: if nums[-1] == 0: # tail = len(''.join([str(i) for i in nums]).rstrip('0')) return moveZeroes_main(nums[:-1]) + [0] else: if nums[0] == 0: for j in xrange(1, tail): nums[j-1] = nums[j] nums[-1] = 0 return moveZeroes_main(nums) else: return [nums[0]] + moveZeroes_main(nums[1:tail]) return nums","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"463. Island Perimeter","slug":"island-perimeter","date":"2017-02-26T17:35:00.000Z","updated":"2017-02-27T16:00:00.000Z","comments":true,"path":"2017/02/27/island-perimeter/","link":"","permalink":"http://faramita.us/2017/02/27/island-perimeter/","excerpt":"","text":"DescriptionDifficulty: Easy You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 找 1 组成的「岛」的边界。 Solution1 与 0 交替时、以及 1 元素越界时为边界。定义了一个方法，探测该位置是否为 0，或坐标包含负数，或数组越界。对 1 周围元素使用这个方法，这些情况边界长度加一。 12345678910111213141516171819202122232425262728def testSurround(grid, perimeter, x, y): if x &lt; 0 or y &lt; 0: perimeter += 1 else: try: z = grid[x][y] except IndexError: perimeter += 1 else: if z == 0: perimeter += 1 return perimeterclass Solution(object): def islandPerimeter(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" perimeter = 0 for i in xrange(len(grid)): for j in xrange(len(grid[i])): if grid[i][j] == 1: perimeter = testSurround(grid, perimeter, i, j - 1) perimeter = testSurround(grid, perimeter, i, j + 1) perimeter = testSurround(grid, perimeter, i - 1, j) perimeter = testSurround(grid, perimeter, i + 1, j) return perimeter","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"500. Keyboard Row","slug":"keyboard-row","date":"2017-02-26T17:07:00.000Z","updated":"2017-02-26T17:10:51.000Z","comments":true,"path":"2017/02/27/keyboard-row/","link":"","permalink":"http://faramita.us/2017/02/27/keyboard-row/","excerpt":"","text":"DescriptionDifficulty: Easy Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard. Example 1:Input: [“Hello”, “Alaska”, “Dad”, “Peace”]Output: [“Alaska”, “Dad”] Note:You may use one character in the keyboard more than once.You may assume the input string will only contain letters of alphabet. 给一组词（字母组成），返回一子集，其中单词可仅用键盘上某一行打出。 Solution先创建三个字符串，分别包含键盘上三行的字母（大小写），然后遍历每个单词后续字母是否与第一个字母在同一行；注意发现不同时跳过当前单词节省时间。 12345678910111213141516171819202122232425262728293031class Solution(object): def findWords(self, words): \"\"\" :type words: List[str] :rtype: List[str] \"\"\" row1 = 'qwertyuiopQWERTYUIOP' row2 = 'asdfghjklASDFGHJKL' row3 = 'zxcvbnmZXCVBNM' rslt = [] if words == []: return [] for i in words: lead = [] if i[0] in row1: lead = row1 elif i[0] in row2: lead = row2 elif i[0] in row3: lead = row3 diff = 0 for j in i: if j not in lead: diff = 1 break if diff == 0: rslt.append(i) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"461. Hamming Distance","slug":"hamming-distance","date":"2017-02-26T02:39:00.000Z","updated":"2017-02-26T02:43:05.000Z","comments":true,"path":"2017/02/26/hamming-distance/","link":"","permalink":"http://faramita.us/2017/02/26/hamming-distance/","excerpt":"","text":"DescriptionDifficulty: Easy The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 231. Example:Input: x = 1, y = 4 Output: 2 Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. Solution先转换为二进制，将短的一方补足位数（0），然后两个数字相加。若元素相同，结果 是 0 或者 2，因此返回合并数组中 1 的数量。 123456789101112131415161718192021222324from operator import addclass Solution(object): def hammingDistance(self, x, y): \"\"\" :type x: int :type y: int :rtype: int \"\"\" if x == y: return 0 x_s = [int(i) for i in bin(x)[2:]] y_s = [int(i) for i in bin(y)[2:]] if len(y_s) &lt; len(x_s): x_s, y_s = y_s, x_s if len(x_s) &lt; len(y_s): x_s = [0] * (len(y_s) - len(x_s)) + x_s comb = map(add, x_s, y_s) return comb.count(1)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"104. Maximum Depth of Binary Tree","slug":"maximum-depth-of-binary-tree","date":"2017-02-24T16:41:17.000Z","updated":"2017-02-24T16:43:37.000Z","comments":true,"path":"2017/02/25/maximum-depth-of-binary-tree/","link":"","permalink":"http://faramita.us/2017/02/25/maximum-depth-of-binary-tree/","excerpt":"","text":"DescriptionDifficulty: Easy Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Solution其实只是深度遍历，同时记录深度。此处使用最简单的中序遍历，stack 在押入节点的同时压入该节点高度，以便取出节点同时恢复高度。 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if root == None: return 0 myStack = [] node = root # working pointer treeDepth = 0 maxDepth = 0 while node != None or myStack != []: while node != None: # if still have left child treeDepth += 1 myStack.append((node, treeDepth)) node = node.left # run out of lefts now = myStack.pop() node = now[0] maxDepth = max(maxDepth, treeDepth) treeDepth = now[1] node = node.right return maxDepth","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"2. Add Two Numbers","slug":"add-two-numbers","date":"2017-02-24T16:01:00.000Z","updated":"2017-02-25T09:48:50.000Z","comments":true,"path":"2017/02/25/add-two-numbers/","link":"","permalink":"http://faramita.us/2017/02/25/add-two-numbers/","excerpt":"","text":"DescriptionDifficulty: Easy You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solution实现一个低位到高位的加法运算。注意进位即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" l_r = ListNode(0) head = l_r plus1 = 0 while l1 != None or l2 != None: if plus1 == 0: l_n = ListNode(0) l_r.next = l_n l_r = l_n if l1 == None: l_r.val = l2.val + plus1 elif l2 == None: l_r.val = l1.val + plus1 else: l_r.val = l1.val + l2.val + plus1 plus1 = 0 if l_r.val &gt;= 10: plus1 = 1 l_r.val = l_r.val - 10 if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if plus1 == 1: l_n = ListNode(1) l_r.next = l_n l_r = l_n return head.next","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"3. Longest Substring Without Repeating Characters","slug":"longest-substring-without-repeating-characters","date":"2017-02-23T04:19:24.000Z","updated":"2017-02-24T16:49:35.000Z","comments":true,"path":"2017/02/23/longest-substring-without-repeating-characters/","link":"","permalink":"http://faramita.us/2017/02/23/longest-substring-without-repeating-characters/","excerpt":"","text":"DescriptionDifficulty: Medium Given a string, find the length of the longest substring without repeating characters. Example1:Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution重点是字符串超长时的执行效率。 我使用的方法：一个指针指向 substring 最右端，作为工作指针不停向右；另一个指针初始指向字符串开头；遇到重复时指向字符串开头的指针向右移动一个，即 substring 去掉头部一个字符，再检测指向 substring 最右端的指针指向的字母是否重复。 这样实现仅需要遍历一遍整个字符串。 12345678910111213141516171819202122class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) &lt;= 1: return len(s) sub = '' max_l = 0 i = 0 while i &lt; len(s): if s[i] not in sub: sub += s[i] max_l = max(max_l, len(sub)) i += 1 else: sub = sub[1:] return max_l","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"7. Reverse Integer","slug":"reverse-integer","date":"2017-02-22T16:05:30.000Z","updated":"2017-02-23T04:18:52.000Z","comments":true,"path":"2017/02/23/reverse-integer/","link":"","permalink":"http://faramita.us/2017/02/23/reverse-integer/","excerpt":"","text":"DescriptionDifficulty: Easy Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution123456789101112131415class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" x_s = str(x)[::-1] if x &lt; 0: x_s = '-' + x_s[:-1] if int(x_s) &gt; 2147483647 or int(x_s) &lt; -2147483648: return 0 else: return int(x_s)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"1. Two Sum","slug":"two-sum","date":"2017-02-22T10:43:48.000Z","updated":"2017-02-23T04:12:35.000Z","comments":true,"path":"2017/02/22/two-sum/","link":"","permalink":"http://faramita.us/2017/02/22/two-sum/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution1234567891011class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"Hello World!","slug":"hello-world","date":"2017-02-22T02:17:42.000Z","updated":"2017-02-23T04:12:52.000Z","comments":true,"path":"2017/02/22/hello-world/","link":"","permalink":"http://faramita.us/2017/02/22/hello-world/","excerpt":"","text":"终于有了一个足够强大的动机让我真正开始写博客。本博客的主要内容将是算法及其他编码的笔记，以及一些思考。","categories":[],"tags":[{"name":"thinking","slug":"thinking","permalink":"http://faramita.us/tags/thinking/"}]}]}