{"meta":{"title":"ä¹‹è¨€ç‰‡è¯­","subtitle":null,"description":"Buried alive.","author":"4faramita","url":"http://faramita.us"},"pages":[],"posts":[{"title":"A Update Of The Template Tool For My Blog","slug":"a-update-of-the-template-tool-for-my-blog","date":"2017-04-27T04:37:09.000Z","updated":"2017-04-27T04:52:05.000Z","comments":true,"path":"2017/04/27/a-update-of-the-template-tool-for-my-blog/","link":"","permalink":"http://faramita.us/2017/04/27/a-update-of-the-template-tool-for-my-blog/","excerpt":"","text":"åšå®¢æ¨¡æ¿å·¥å…·å†æ¬¡æ›´æ–°ï¼æ¯•ç«Ÿè¿™ä¸ªåšå®¢å¹¶ä¸åªæ˜¯ä¸ºäº†è®°å½•é¢˜ç›®ï¼ˆè™½ç„¶è¿™æ˜¯ä¸€ä¸ªä¸»è¦ç”¨é€”ï¼‰ï¼Œé‚£ä¹ˆå†™ä½œå…¶ä»–å†…å®¹æ—¶éœ€è¦ä¸€ä¸ªç®€å•çš„æ¨¡æ¿ï¼ŒåªåŒ…å«æ ‡é¢˜ï¼Œæ ‡ç­¾å’Œæ—¶é—´ã€‚äºæ˜¯æœ‰äº†è¿™æ¬¡æ›´æ–°ã€‚åŒæ—¶ï¼Œæˆ‘æŠŠè¿™ä¸ªå°è„šæœ¬æ”¾åœ¨äº† GitHub ä¸Šï¼Œè™½ç„¶æˆ‘å‡ ä¹ç¡®å®šè¿™ä¸ªè½®å­å·²ç»è¢«é€ äº†æ— æ•°éäº†ï¼Œä½†æ˜¯è‡ªå·±ç”¨è¿˜æ˜¯è‡ªå·±å†™æ¯”è¾ƒæ–¹ä¾¿ã€‚","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"19. Remove Nth Node From End of List","slug":"remove-nth-node-from-end-of-list","date":"2017-04-25T12:35:55.000Z","updated":"2017-04-25T12:40:36.000Z","comments":true,"path":"2017/04/25/remove-nth-node-from-end-of-list/","link":"","permalink":"http://faramita.us/2017/04/25/remove-nth-node-from-end-of-list/","excerpt":"","text":"DescriptionDifficulty: Medium Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note:Given n will always be valid.Try to do this in one pass. é¢˜æ„:åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ã€‚è¦æ±‚ä»…éå†ä¸€éã€‚ Solutionæœ€ç®€å•çš„æ–¹æ³•ï¼šå¿«æ…¢æŒ‡é’ˆã€‚å¿«æŒ‡é’ˆé¢†å…ˆæ…¢æŒ‡é’ˆ n - 1ï¼Œå¿«æŒ‡é’ˆåˆ°è¾¾æœ«å°¾æ—¶ï¼Œåˆ é™¤æ…¢æŒ‡é’ˆæŒ‡å‘å…ƒç´ ã€‚ä¸ºäº†åˆ é™¤æ–¹ä¾¿ï¼Œå†å®šä¹‰ slow_p æŒ‡å‘æ…¢æŒ‡é’ˆä¹‹å‰å…ƒç´ ã€‚é¡ºä¾¿ï¼Œå¯ä»¥åˆ¤æ–­ä¸€äº›è¾¹é™…çŠ¶å†µï¼šfast, slow ä¸ slow_p éƒ½åˆå§‹åŒ–ä¸º headï¼Œå› æ­¤ï¼š è‹¥ fast == slow == slow_pï¼Œåˆ™åŸé“¾è¡¨åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶ä¸”åˆ é™¤è¿™ä¸ªèŠ‚ç‚¹ï¼Œè¿”å› [] è‹¥ slow == slow_pï¼Œåˆ™éœ€è¦åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œè¿”å› head.next 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" fast, slow, slow_p = head, head, head n_copy = n - 1 while n_copy &gt; 0: fast = fast.next n_copy -= 1 while fast.next: fast = fast.next slow_p = slow slow = slow.next if fast == slow == slow_p: return [] elif slow == slow_p: return head.next else: slow_p.next = slow.next return head","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"ä¸€ä¸ªæ›´æ–° ShadowsocksX-NG-R8 çš„å°å·¥å…·","slug":"ShadowsocksX-NG-R8-Updater","date":"2017-04-14T15:48:02.000Z","updated":"2017-04-14T16:03:53.000Z","comments":true,"path":"2017/04/14/ShadowsocksX-NG-R8-Updater/","link":"","permalink":"http://faramita.us/2017/04/14/ShadowsocksX-NG-R8-Updater/","excerpt":"","text":"åœ¨å›½å†…ä¸Šç½‘çš„è¯ï¼Œç»•ä¸å¼€ GFW è¿™ä¸ªè¯é¢˜ã€‚è¦ç¿»å¢™çš„è¯ï¼Œå¦‚æœä½ åœ¨ç”¨ macOSï¼Œé‚£ä¹ˆ ShadowsocksX-NG-R8 æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©ã€‚ShadowsocksX-NG ä» ShadowsocksX fork è€Œæ¥ï¼Œè€Œ ShadowsocksX-NG-R8 åˆæ˜¯ ShadowsocksX-NG çš„æ”¯æŒ ShadowsocksR çš„ forkï¼Œç›®å‰ç»´æŠ¤ååˆ†æ´»è·ƒã€‚ ç»´æŠ¤æ´»è·ƒå°±æ„å‘³ç€æ›´æ–°é¢‘ç¹ï¼Œå½“ç„¶è¿™æ˜¯ä»¶å¥½äº‹ï¼Œä½†æ˜¯æ¯æ¬¡æ‰“å¼€ç½‘é¡µæ‰‹å·¥ä¸‹è½½å®åœ¨å¤ªéº»çƒ¦ã€‚äºæ˜¯å†™äº†ä¸ªè¿™ä¸ªå°å·¥å…·ç”¨äºè‡ªåŠ¨ä¸‹è½½æœ€æ–°ç‰ˆæœ¬ã€‚ ShadowsocksX-NG-R8-Updater ç”¨æ³•å…‹éš†ä»“åº“ï¼š git clone git@github.com:4faramita/ShadowsocksX-NG-R8-Updater.git è„šæœ¬ç”¨ Node å†™æˆï¼ŒåŸºäº cheerio å’Œ requestã€‚å› æ­¤ä½ éœ€è¦å®‰è£… Node å’Œ npmï¼š brew install node npm ç„¶åå®‰è£…ä¾èµ–ï¼š npm install cheerio request -g ç„¶åè¿è¡Œå³å¯ï¼Œæ–‡ä»¶ä¼šä¸‹è½½åˆ°è„šæœ¬æ‰€åœ¨ç›®å½•ã€‚ cd ShadowsocksX-NG-R8-Updater node updater.js ä»£ç†æ—¢ç„¶ä½ æƒ³ç”¨è¿™ä¸ªè„šæœ¬ï¼Œæˆ‘å‡è®¾ä½ å·²ç»åœ¨ç”¨ ShadowsocksX-NG-R8 å¹¶æ‰“å¼€äº†ã€ŒHTTP ä»£ç†ã€ï¼Œæ‰€ä»¥æœ¬è„šæœ¬ä¼šè‡ªåŠ¨è°ƒç”¨ http://127.0.0.1:1087 ä½œä¸ºé»˜è®¤ HTTP ä»£ç†ã€‚ å¦‚æœä½ ä¸æƒ³ä½¿ç”¨ä»£ç†ï¼Œè¯·ç”¨è¿™ä¸ªå‘½ä»¤ node updater.js -n; å¦‚æœä½ æƒ³ä½¿ç”¨å…¶ä»–ä»£ç†ï¼š node updater.js -y [æœåŠ¡å™¨] [ç«¯å£]. æ¯”å¦‚: node updater.js -y 127.0.0.1 1087. æ— éœ€æ‰‹å·¥æ·»åŠ http://ï¼Œè¿™ä¹Ÿæ„å‘³ç€æœ¬è„šæœ¬åªæ”¯æŒ HTTP ä»£ç† ä¸‹ä¸€æ­¥æœªæ¥è¿˜æœ‰ä¸€äº›ä¸ç—›ä¸ç—’çš„åŠŸèƒ½éœ€è¦æ·»åŠ ï¼Œæ¯”å¦‚ è‡ªå®šä¹‰ä¸‹è½½è·¯å¾„ æ ¡éªŒ GPG Sig æ˜¾ç¤ºä¸‹è½½è¿›åº¦ ç”¨ Python é‡å†™","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"17. Letter Combinations of a Phone Number","slug":"letter-combinations-of-a-phone-number","date":"2017-04-10T16:49:26.000Z","updated":"2017-04-10T16:55:45.000Z","comments":true,"path":"2017/04/11/letter-combinations-of-a-phone-number/","link":"","permalink":"http://faramita.us/2017/04/11/letter-combinations-of-a-phone-number/","excerpt":"","text":"DescriptionDifficulty: Medium Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Input:Digit string \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note:Although the above answer is in lexicographical order, your answer could be in any order you want. é¢˜æ„:ç»™å‡ºä¸€ä¸²æ•°å­—ï¼Œæ±‚è¿™ä¸²æ•°å­—åœ¨ T9 é”®ç›˜ä¸Š èƒ½æ‰“å‡ºçš„æ‰€æœ‰å­—æ¯ç»„åˆã€‚ Solutionç®—æ³•å¾ˆç®€å•ï¼Œé¢„è®¾ä¸€ä¸ªå­—å…¸ï¼ŒæŸ¥æ¯ä¸ªæ•°çš„å¯¹åº”å­—æ¯ï¼Œç„¶åæ±‚ç»„åˆå³å¯ã€‚é‡ç‚¹åœ¨äº Python æœ‰ä¸€ä¸ªå¼ºå¤§çš„å·¥å…·é›†ï¼šitertoolsitertools é‡Œé¢çš„ combination ç­‰æ–¹æ³•ä¹‹å‰ä¹Ÿç”¨è¿‡å¾ˆå¤šæ¬¡ï¼Œè¿™æ¬¡ç”¨åˆ°çš„æ˜¯ productã€‚è¿™ä¸ªæ–¹æ³•èƒ½äº§ç”Ÿè¾“å…¥æ•°ç»„ï¼ˆæ¯ç»„ä¸€ä¸ªå…ƒç´ ï¼‰æ‰€èƒ½ç»„æˆçš„æ‰€æœ‰ç»„åˆï¼Œæ–¹æ³•æ–‡æ¡£ä¸­çš„è¯´æ³•æ˜¯â€œRoughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B).â€ã€‚çŸ¥é“äº†è¿™ä¸ªæ–¹æ³•è¿™é“é¢˜ä¹Ÿå°±è§£å¼€äº†ã€‚ 1234567891011121314151617181920212223242526272829import itertoolsclass Solution(object): def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\" num_pad = &#123; '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' &#125; if digits == '': return [] chars = [] for n in digits: chars.append([i for i in num_pad[n]]) char_list = list(itertools.product(*chars)) result = [] for s in char_list: result.append(''.join(list(s))) return result","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"15. 3Sum","slug":"3sum","date":"2017-04-10T16:26:02.000Z","updated":"2017-04-10T17:02:26.000Z","comments":true,"path":"2017/04/11/3sum/","link":"","permalink":"http://faramita.us/2017/04/11/3sum/","excerpt":"","text":"DescriptionDifficulty: Medium Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] é¢˜æ„:ç»™å‡ºä¸€æ•°ç»„ï¼Œè¿”å›æ•°ç»„ä¸­å’Œä¸º 0 çš„ä¸‰ä¸ªå…ƒç´ çš„ç»„åˆã€‚è¦æ±‚å»é‡ã€‚ Solutionä¸€é“ç»å…¸çš„é¢˜ã€‚å…ˆè€ƒè™‘ 2 sumï¼Œé’ˆå¯¹æœ‰åºæ•°åˆ—ï¼Œå¤´å°¾åŒæŒ‡é’ˆï¼Œè‹¥å½“å‰å’Œå¤§äºè¦æ±‚ï¼Œå°¾æŒ‡é’ˆå‰ç§»ï¼›è‹¥å°äºè¦æ±‚ï¼Œå¤´æŒ‡é’ˆåç§»ã€‚æ—¶é—´å¤æ‚åº¦ O(n)é‚£ä¹ˆ 3 sum åªè¦é’ˆå¯¹æ¯ä¸ªå…ƒç´ ç®— 2 sum å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ O(n ^ 2)ã€‚é—®é¢˜åœ¨äºå»é‡ã€‚é¦–å…ˆçš„æƒ³æ³•æ˜¯ç”¨é›†åˆï¼Œç„¶è€Œé›†åˆæ— æ³•å‚¨å­˜æ•°ç»„ï¼Œå› æ­¤å…ˆå°†ç»“æœæ•°ç»„æ’åºå¹¶è½¬æ¢ä¸ºå…ƒç»„ã€‚ç„¶è€Œå³ä½¿ç”¨é›†åˆï¼Œä¹Ÿæ˜¯è¦å°è¯•æ’å…¥å¾ˆå¤šæ¬¡çš„ï¼›å¦å¤–é›†åˆåœ¨å®ç°ä¸Šç»ˆç©¶æ˜¯è¦æŸ¥æ‰¾çš„ï¼Œå»é‡ä¸å¯èƒ½æ²¡æœ‰ä»£ä»·ã€‚å› æ­¤æ›´å¥½å¾—åšæ³•æ˜¯åœ¨æŒ‡é’ˆå¤„è¿‡æ»¤ï¼Œè‹¥æŒ‡é’ˆå½“å‰å€¼ä¸ä¸Šä¸€ä¸ªå€¼ç›¸ç­‰ï¼Œåˆ™è·³è¿‡å½“å‰å€¼ã€‚è¿˜æœ‰ä¸€ä¸ªç‚¹ï¼šä¸€å¼€å§‹ä¸ºäº†é˜²æ­¢è¶Šç•Œï¼Œæˆ‘åœ¨å»é‡ä»£ç éƒ¨åˆ†å¤–é¢åŠ ä¸Šäº† tryï¼Œç„¶è€Œæ— æ³•æ»¡è¶³æ—¶é—´è¦æ±‚ï¼›å»æ‰ try è¯­å¥å°±å¯ä»¥äº†ã€‚try çš„å¼€é”€æ¯”æˆ‘æƒ³è±¡çš„å¤§ã€‚ 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() result = set() length = len(nums) if length &lt; 3: return [] elif length == 3: if sum(nums) == 0: return[sorted(nums)] for i in xrange(len(nums) - 2): rest = -nums[i] head = i + 1 tail = length - 1 while tail &gt; head: left = nums[head] right = nums[tail] cur_sum = left + right if cur_sum == rest: result.add(tuple(sorted([-rest, left, right]))) head += 1 tail -= 1 while head &lt; tail and nums[head - 1] == nums[head]: head += 1 while head &lt; tail and nums[tail + 1] == nums[tail]: tail -= 1 elif cur_sum &gt; rest: tail -= 1 else: head += 1 return list(result)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"11. Container With Most Water","slug":"container-with-most-water","date":"2017-04-10T15:16:59.000Z","updated":"2017-04-10T15:31:39.000Z","comments":true,"path":"2017/04/10/container-with-most-water/","link":"","permalink":"http://faramita.us/2017/04/10/container-with-most-water/","excerpt":"","text":"DescriptionDifficulty: Medium Given n non-negative integers a1, a2, â€¦, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2. é¢˜æ„:ç»™å‡ºä¸€å †æ•´æ•°åæ ‡ç‚¹ï¼Œæ¯ä¸ªç‚¹çš„é«˜åº¦ç›¸å½“äºå¯¹åº”æŒ¡æ¿çš„é«˜åº¦ï¼›é€‰å‡ºä¸¤ä¸ªæŒ¡æ¿ï¼Œä¸ x è½´ç»„æˆæ°´æ¡¶ï¼Œæ±‚æœ€å¤§å®¹é‡ã€‚ Solutionå®¹é‡ç”±çŸ­æ¿å’Œå®½åº¦ï¼ˆä¸¤ä¸ªç‚¹åœ¨ x ä¸Šçš„æŠ•å½±è·ç¦»ï¼‰å†³å®šã€‚è®¾ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€å¤´ä¸€å°¾ã€‚vol å‡½æ•°è®¡ç®—ç»™å‡ºä¸¤ä¸ªæŒ‡é’ˆå½¢æˆçš„å®¹ç§¯ã€‚max_vol å‚¨å­˜æœ€å¤§å®¹ç§¯ã€‚æ¯ç®—å®Œä¸€æ¬¡ï¼Œè¾ƒçŸ­çš„æ¿å­å‘å¯¹æ–¹ç§»åŠ¨ä¸€æ¬¡ã€‚ 1234567891011121314151617181920212223def vol(height, x, y): return (height[x] if height[x] &lt; height[y] else height[y]) * (y - x)class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" max_vol = 0 length = len(height) head, tail = 0, length - 1 while tail &gt; head: cur_vol = vol(height, head, tail) max_vol = cur_vol if cur_vol &gt; max_vol else max_vol if height[head] &lt; height[tail]: head += 1 else: tail -= 1 return max_vol","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"5. Longest Palindromic Substring","slug":"longest-palindromic-substring","date":"2017-04-03T09:09:34.000Z","updated":"2017-04-03T09:35:42.000Z","comments":true,"path":"2017/04/03/longest-palindromic-substring/","link":"","permalink":"http://faramita.us/2017/04/03/longest-palindromic-substring/","excerpt":"","text":"DescriptionDifficulty: Medium Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:Input: â€œbabadâ€ Output: â€œbabâ€ Note: â€œabaâ€ is also a valid answer. Example:Input: â€œcbbdâ€ Output: â€œbbâ€ é¢˜æ„:æ‰¾åˆ°ç»™å®šå­—ç¬¦ä¸²ä¸­æœ€é•¿çš„ï¼ˆè¿ç»­ï¼‰å›æ–‡å­å­—ç¬¦ä¸² Solutioné¦–å…ˆæƒ³åˆ°çš„æ–¹æ³•æ˜¯è®¾ç½®ä¸€ä¸ª len(s) åˆ° 1 çš„çª—å£ï¼Œåœ¨å­—ç¬¦ä¸²ä¸Šæ»‘åŠ¨ï¼Œå› ä¸ºæ˜¯å€’åºï¼Œæ‰€ä»¥ä¸€æ—¦æ‰¾åˆ°å°±æ˜¯æœ€é•¿ï¼Œå¯ä»¥ç›´æ¥è¿”å›ã€‚12345678910111213141516171819202122232425class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" length = len(s) if length &lt;= 1: return s max_range = (0, 0) found = False for win in xrange(length, 0, -1): for head in xrange(0, length - win + 1): cur_str = s[head:head + win] if win % 2 == 0: # even l_half, r_half = cur_str[:win / 2], cur_str[win / 2:] elif win % 2 == 1: # odd l_half, r_half = cur_str[:win // 2], cur_str[win // 2 + 1:] if l_half == r_half[::-1]: max_range = (head, head + win) found = True break if found: break return s[max_range[0]:max_range[1]] ä¸€ç‚¹ tipï¼šæœ¬æ¥å¯¹æ¯”çª—å£å†…æ•´ä¸ªå­—ç¬¦ä¸²ä¸å…¶åå‘æ˜¯å¦ç›¸ç­‰ï¼Œæœªèƒ½æ»¡è¶³å®éªŒå¤æ‚åº¦è¦æ±‚ï¼›åæ¥é€‰æ‹©å°†å­—ç¬¦ä¸²åˆ‡æˆä¸¤åŠï¼Œå¯¹æ¯”å‰ä¸€åŠä¸åä¸€åŠçš„åè½¬ï¼Œæ—¶é—´å¤æ‚åº¦è¦æ±‚å³å¯æ»¡è¶³ã€‚","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"53. Maximum Subarray","slug":"maximum-subarray","date":"2017-03-17T07:00:18.000Z","updated":"2017-03-17T09:29:28.000Z","comments":true,"path":"2017/03/17/maximum-subarray/","link":"","permalink":"http://faramita.us/2017/03/17/maximum-subarray/","excerpt":"","text":"DescriptionDifficulty: Easy Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. click to show more practice. More practice:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. é¢˜æ„:ç»™å‡ºä¸€æ•°ç»„ numsï¼Œæ±‚æ•°ç»„ä¸­å’Œæœ€å¤§çš„è¿ç»­å­åºåˆ—ã€‚ Solutionæœ€ç®€å•çš„æƒ³æ³•è‡ªç„¶æ˜¯æšä¸¾æ‰€æœ‰å¤§å°çš„çª—å£ï¼Œä» len(nums) åˆ° 1ï¼›æ»‘åŠ¨çª—å£åˆ°æ¯ä¸ªå¯èƒ½çš„ä½ç½®ï¼Œæ±‚å’Œï¼Œè®°å½•å’Œçš„æœ€å¤§å€¼ã€‚ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # base cases if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] # window size init as len(nums) - 1 window = len(nums) - 1 # window position init as right start = len(nums) - window # this is the case when window size = len(nums) # and this will store the max of sums sum_max = sum(nums) # every possible window size: [1, len(nums) - 1] while window &gt; 0: # every possible position of this window while start &gt;= 0: sum_curr = sum(nums[start:start+window]) sum_max = max(sum_curr, sum_max) # window slides left start -= 1 # window size minus 1 window -= 1 # reset window position to the very right start = len(nums) - window return sum_max ä¸ç”¨è¯´ï¼Œè¿™ä¹ˆ virgin è¿™ä¹ˆ naive çš„ç®—æ³•å½“ç„¶æ˜¯æ— æ³•æ»¡è¶³æ—¶é—´å¤æ‚åº¦è¦æ±‚çš„ã€‚ä¹‹åï¼Œæˆ‘è€ƒè™‘çª—å£ä» 1 å¼€å§‹ï¼Œç”¨å­—å…¸å‚¨å­˜æ‰€æœ‰ç®—è¿‡çš„ sumï¼Œä¸‹æ¬¡ä½¿ç”¨æ—¶ç›´æ¥è¯»å–è€Œä¸ç”¨å†ç®—ä¸€éã€‚ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142def maxSubArray(nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # base cases length = len(nums) if length == 0: return 0 elif length == 1: return nums[0] # all possible window sizes in [1, length - 1] window = 1 # all possible positions from right start = len(nums) - window # stroe the max of sums sum_max = sum(nums) # store all sums for every position of every window sizes sum_set = &#123;&#125; while window &lt; length: while start &gt;= 0: # store all single \"sums\" if window == 1: sum_curr = nums[start] # get current sum by last round sum + single \"sum\" elif window &gt; 1: sum_curr = sum_set[(start, start + window - 1)] + nums[start + window - 1] # store current sum sum_set[(start, start+window)] = sum_curr # print(nums[start:start+window], sum_curr, sum_max) # store current max sum sum_max = max(sum_curr, sum_max) # slide the window start -= 1 # enlarge the window size window += 1 # and reset the position of the window start = len(nums) - window return sum_max è¿™ä¸ªç®—æ³•åˆ™å°†æ‰§è¡Œæ—¶é—´ä»åŸæ¥çš„ 2.5s ä¼˜åŒ–åˆ°äº† 1s ä»¥å†…ã€‚ä½†æ˜¯æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¯ O(n^2) è¿™é“é¢˜æ˜¯å¯ä»¥ç”¨åŠ¨æ€è§„åˆ’çš„ã€‚éå†åˆ°æ¯ä¸ªèŠ‚ç‚¹æ—¶éƒ½æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼šé€‰æ‹©ä¸Šä¸€ä¸ª sum åŠ å½“å‰æ•°ï¼Œæˆ–è€…é€‰æ‹©å½“å‰æ•°ä½œä¸ºæ–°çš„ sumã€‚ç®—æ³•å¦‚ä¸‹ï¼š 12345678910def maxSubArray(A): if not A: return 0 curSum = maxSum = A[0] for num in A[1:]: curSum = max(num, curSum + num) maxSum = max(maxSum, curSum) return maxSum P.S å†™è¿™é“é¢˜çš„æ—¶å€™ LeetCode æŒ‚äº†â€¦â€¦ ğŸ¤¦","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"125. Valid Palindrome","slug":"valid-palindrome","date":"2017-03-17T05:49:24.000Z","updated":"2017-03-17T06:22:19.000Z","comments":true,"path":"2017/03/17/valid-palindrome/","link":"","permalink":"http://faramita.us/2017/03/17/valid-palindrome/","excerpt":"","text":"DescriptionDifficulty: Easy Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,â€œA man, a plan, a canal: Panamaâ€ is a palindrome.â€œrace a carâ€ is not a palindrome. Note:Have you consider that the string might be empty? This is a good question to ask during an interview.For the purpose of this problem, we define empty string as valid palindrome. é¢˜æ„:ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡ã€‚è¦æ±‚ï¼š ç©ºå­—ç¬¦ä¸²ä¸ºå›æ–‡ï¼› å¿½ç•¥éå­—æ¯æ•°å­—çš„å­—ç¬¦ï¼› å¤§å°å†™ä¸æ•æ„Ÿã€‚ Solutionç®—æ³•å¹¶ä¸éš¾ï¼Œå­—ç¬¦ä¸²è½¬å°å†™ï¼Œè¿‡æ»¤éæ•°å­—ä¸éå­—æ¯ï¼Œåˆ‡åˆ†å­—ç¬¦ä¸²ä¸ºå‰åä¸¤åŠï¼Œå¯¹æ¯”å³å¯ã€‚OJ çš„æœ€åä¸€ä¸ª test case æ˜¯ä¸€ä¸ªé•¿è¾¾ 14380 è¡Œçš„å¤æ‚å­—ç¬¦ä¸²ï¼Œè¯¥ç®—æ³•å¯ä»¥åœ¨ 0.07s å†…å®Œæˆåˆ¤æ–­ã€‚ä½†æ˜¯ï¼è¿™ä¸ªç®—æ³•ä¾ç„¶è¶…è¿‡äº†æ—¶é—´é™åˆ¶ï¼Fï¼ 123456789101112131415161718192021class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" if s == '': return True s = s.lower() s_clean = '' for c in s: if c.isalpha() or c.isdigit(): s_clean += c length = len(s_clean) if length % 2 == 0: s_l = s_clean[:length / 2] s_r = s_clean[length / 2:] else: s_l = s_clean[:(length - 1) / 2] s_r = s_clean[(length + 1) / 2:] return s_l == s_r[::-1] äºæ˜¯æˆ‘å†™äº†å¦ä¸€ä¸ªç®—æ³•ï¼Œä½¿ç”¨åŒæŒ‡é’ˆåŸåœ°æ‰§è¡Œã€‚ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" head, tail = 0, len(s) - 1 while tail &gt; head: if not s[tail].isalnum(): tail -= 1 continue if not s[head].isalnum(): head += 1 continue if s[tail].lower() != s[head].lower(): return False tail -= 1 head += 1 return True è¿™ä¸ªç®—æ³•åœ¨å¤„ç†ä¸Šé¢æåˆ°çš„å¤§å­—ç¬¦ä¸²æ—¶è¿è¡Œæ—¶é—´ç¨³å®šåœ¨ 0.75sï¼Œç„¶è€Œ LeetCodeOJ ç«Ÿç„¶åˆ¤æ–­é€šè¿‡ã€‚ å½“ç„¶ï¼ŒåŸåœ°æ‰§è¡Œè¾¾åˆ°ç›¸ä¼¼æ—¶é—´å¤æ‚åº¦çš„ç¡®æ˜¯æ›´å¥½çš„å®è·µã€‚","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"204. Count Primes","slug":"count-primes","date":"2017-03-16T15:07:28.000Z","updated":"2017-03-17T06:30:50.000Z","comments":true,"path":"2017/03/16/count-primes/","link":"","permalink":"http://faramita.us/2017/03/16/count-primes/","excerpt":"","text":"DescriptionDifficulty: Easy (Which I do not agree AT ALL.) Description:Count the number of prime numbers less than a non-negative number, n. é¢˜æ„:è¾“å…¥ä¸€ä¸ªæ•°ï¼Œè¾“å‡ºå°äºè¿™ä¸ªæ•°çš„æ‰€æœ‰æ­£æ•´æ•°ä¸­æœ‰å¤šå°‘ä¸ªè´¨æ•°ã€‚ Solutionå¾ˆå¤šæ•°çš„ç´ æ€§æ£€æµ‹ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯å…³é”®ã€‚æœ€ç®€å•çš„æƒ³æ³•æ˜¯éå†æ¯ä¸ªæ•°ï¼Œæ£€æŸ¥æ¯ä¸ªæ•°çš„ç´ æ€§ã€‚å°½ç®¡æ£€æŸ¥ç´ æ€§çš„å‡½æ•°æ•ˆç‡ä¸ä½ï¼Œä½†æ˜¯æ€»ä½“æ•ˆç‡è¿˜æ˜¯éå¸¸ä½ ä¸€ç•ªæŸ¥æ‰¾ä¹‹åï¼Œæˆ‘é€‰æ‹©äº†åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•ã€‚è¿™æ˜¯ä¸€ä¸ªå¤è€è€Œç®€å•çš„ç®—æ³•ï¼Œç”¨æ¥æ‰¾å‡ºä¸€å®šèŒƒå›´å†…æ‰€æœ‰ç´ æ•°ï¼Œæµç¨‹å¦‚ä¸‹ï¼š åˆå§‹åŒ–ä¸¤ä¸ªæ•°åˆ— nums å’Œ statusï¼Œnums å‚¨å­˜ä» 2 å¼€å§‹æ‰€æœ‰å¾…æŸ¥çš„æ•°ï¼ˆå› ä¸º 1 ä¸æ˜¯ç´ æ•°ï¼‰ï¼Œstatus å‚¨å­˜ nums ä¸­æ¯ä¸ªæ•°æ˜¯å¦ä¸ºç´ æ•°ï¼Œåˆå§‹åŒ–ä¸º Trueã€‚ ä»ç¬¬ä¸€ä¸ªå…ƒç´  2 å¼€å§‹ï¼Œå°† nums ä¸­æ¯ä¸€ä¸ªè¯¥å…ƒç´ ï¼ˆè¿™é‡Œä¸º 2ï¼‰ çš„å€æ•°æ ‡è®°ä¸ºåˆæ•°ï¼Œæ–¹æ³•æ˜¯å°† status æ•°ç»„å¯¹åº”ä½ç½®èµ‹å€¼ Falseã€‚ å½“æœ€è¿‘æ£€æŸ¥å‡ºçš„ç´ æ•°çš„å¹³æ–¹å·²ç»å¤§äº nums ä¸­æœ€å¤§çš„æ•°æ—¶ï¼Œè®¤ä¸ºä¹‹åæ‰€æœ‰æœªæ ‡è®°ä¸ºåˆæ•°çš„æ•°éƒ½æ˜¯è´¨æ•°ï¼Œç®—æ³•ç»“æŸã€‚ä»£ç å¦‚ä¸‹12345678910111213141516171819202122232425262728293031class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\" # base cases if n &gt;= 0 and n &lt;= 1: return 0 elif n &lt;= 4: return n - 2 nums = [i for i in range(2, n)] # all the numbers status = [True] * len(nums) # whether a number in nums a prime last_prime = 0 # store the last prime found for elem in enumerate(nums): # elem: (position, value) if (last_prime ** 2) &gt; n - 1: break if status[elem[0]] is False: continue last_prime = elem[1] for p in range(elem[0] + 1, len(nums)): if nums[p] % elem[1] == 0: status[p] = False total = 0 for j in status: if j is True: total += 1 return total ç„¶è€Œï¼Œä»¤äººéš¾ä»¥ç½®ä¿¡çš„æ˜¯ï¼Œè¿™ä¸ªç®—æ³•ï¼Œåœ¨è¾“å…¥å€¼ä¸ºå…­ä½æ•°æ—¶ï¼Œä¾ç„¶è¶…è¿‡äº†æ—¶é—´é™åˆ¶ï¼ˆå…·ä½“æ¥è¯´æ‰§è¡Œæ—¶é—´è¾¾åˆ°äº†åç§’ä»¥ä¸Šï¼‰ã€‚ äºæ˜¯æˆ‘ä¸ç”˜å¿ƒåœ°ç‚¹å¼€äº†è¿™é“é¢˜çš„ hint éƒ¨åˆ†ã€‚è¿™é“é¢˜çš„ hintï¼Œé”¦å›Šä¸€èˆ¬ï¼Œå±‚å±‚åµŒå¥—ï¼Œä¸€ä¸ªé—®é¢˜å¼•å‡ºå¦ä¸€ä¸ªé—®é¢˜ï¼Œãªã‚“ã¨ã€æœ‰æ•´æ•´å…«ä¸ª hintï¼å‰åŠéƒ¨åˆ†ä¹Ÿå¼•å¯¼ä½¿ç”¨æ¯ä¸ªæ•°çš„ç´ æ€§æ£€æµ‹ï¼Œä¹‹åè¯´åªéœ€è¦æ£€æµ‹å‰ nï¼2 çš„æ•°ï¼Œæ›´è¿›ä¸€æ­¥å‘ç°åªéœ€è¦æ£€æµ‹å‰ n^(1/2) çš„æ•°ã€‚ä¹‹åä¹Ÿå¼•å‡ºäº†æˆ‘ä¹‹å‰æåˆ°çš„åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•ï¼Œè¯¥æ–¹æ³•ç¡®å®æ˜¯æ£€æµ‹å¤§æ‰¹é‡æ•°æ˜¯å¦ä¸ºç´ çš„å¥½æ–¹æ³•ã€‚æˆ‘æŒ‰ç…§ hint çš„å¼•å¯¼ä¼˜åŒ–äº†ç®—æ³•ï¼Œå†æ¬¡å®éªŒã€‚ éšç€ä¸æ–­ä¿®æ”¹ï¼Œæœ€ç»ˆæˆ‘å°†æ­¥é•¿æ”¹ä¸ºåŠ¨æ€ï¼Œä¼˜åŒ–äº†ä¸€ç³»åˆ—äº‹ä»¶ä¸å†…å­˜å¤æ‚åº¦ã€‚æœ€ç»ˆèƒ½åœ¨ 1s å†…æ‰§è¡Œã€‚å› ä¸ºè¿›è¡Œäº†è®¸å¤šä¼˜åŒ–ï¼Œæœ€ç»ˆç­”æ¡ˆä¸­ä¹ŸåŒ…å«è®¸å¤šæ³¨é‡Šï¼Œæ›´å¤šçš„ä¼˜åŒ–å†…å®¹åœ¨æ³¨é‡Šä¸­è¯´æ˜ã€‚å½“ç„¶ï¼Œæˆ‘çœ‹ç­”æ¡ˆäº†ï¼Œä½†æ˜¯æœ€ç»ˆçš„ç®—æ³•å®Œå…¨æ˜¯æˆ‘æ ¹æ®ä¹‹å‰å†™çš„ 8s çš„ç­”æ¡ˆç‹¬ç«‹ä¿®æ”¹è€Œæ¥çš„ã€‚ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\" # base cases if n &gt;= 0 and n &lt;= 1: return 0 elif n &lt;= 4: return n - 2 # all the nums = [i for i in xrange(n)] # but, as rank and value of nums are the same # as a matter of fact, # they all equal to the natural number of that position # so there\\'s no need to actually create that list # every nums\\' status, True for prime status = [True] * n # 0 and 1 are not primes status[0], status[1] = False, False # without list(nums) # I can still do this step # thanks to the natural number # in the range of [2, sqrt(n - 1)] for elem in xrange(2, int((n - 1) ** 0.5) + 1): # if this num is a prime if status[elem]: # from position num ^ 2 p = elem ** 2 # every step num # set status False while p &lt; n: status[p] = False p += elem # return number of Tures return sum(status) é‰´äº hint è¿‡å¤šï¼Œä¹‹å‰å†™çš„è„šæœ¬åˆæ²¡èƒ½æŠ“å›æ¥ï¼Œç°å°†ç½‘å€è´´å‡ºï¼š204. Count Primes","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"155. Min Stack","slug":"min-stack","date":"2017-03-16T10:29:32.000Z","updated":"2017-03-16T10:34:29.000Z","comments":true,"path":"2017/03/16/min-stack/","link":"","permalink":"http://faramita.us/2017/03/16/min-stack/","excerpt":"","text":"DescriptionDifficulty: Easy Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) â€“ Push element x onto stack. pop() â€“ Removes the element on top of the stack. top() â€“ Get the top element. getMin() â€“ Retrieve the minimum element in the stack. Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); â€“&gt; Returns -3.minStack.pop();minStack.top(); â€“&gt; Returns 0.minStack.getMin(); â€“&gt; Returns -2. é¢˜æ„:è‡ªå·±å®ç°ä¸€ä¸ªæ ˆï¼Œé™¤äº†æ¨ã€å¼¹ã€æŸ¥çœ‹æ ˆé¡¶ä»¥å¤–è¿˜è¦æ±‚å¸¸æ•°æ—¶é—´æ‰¾åˆ°æ ˆä¸­æœ€å°å€¼ã€‚ SolutionåŸºæœ¬æ€è·¯æ˜¯ä½¿ç”¨ list ç»“æ„ï¼Œè‡ªå¸¦ pushï¼ˆappendï¼‰ä¸ pop æ–¹æ³•ã€‚top åªéœ€è¦è¿”å›æœ€åä¸€ä¸ªå…ƒç´ ã€‚å¯¹äºæœ€å°å€¼ï¼Œæœ€å•çº¯çš„æ€è·¯æ˜¯ç”¨è‡ªå¸¦æ–¹æ³•è¿”å› min(list)ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦ä¸å…è®¸ã€‚å› æ­¤ç»´æŠ¤ä¸€ä¸ªæœ€å°å€¼ stackï¼Œåœ¨æ¯æ¬¡ push çš„æ—¶é¡ºä¾¿åœ¨æœ€å°å€¼ stack ä¸­ push å½“å‰æœ€å°å€¼ï¼ˆåŒ…æ‹¬è¾“å…¥å€¼ï¼‰ï¼Œæ¯æ¬¡ pop æ—¶æœ€å°å€¼æ ˆä¹Ÿéšä¹‹ popã€‚éœ€è¦è·å–æœ€å°å€¼æ—¶åªéœ€è¦è·å–æœ€å°å€¼ stack çš„æœ€åä¸€ä¸ªå…ƒç´ å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.stack = [] self.min_q = [] def push(self, x): \"\"\" :type x: int :rtype: void \"\"\" self.stack.append(x) if self.min_q == []: self.min_q.append(x) else: self.min_q.append(min(x, self.min_q[-1])) def pop(self): \"\"\" :rtype: void \"\"\" self.stack.pop() self.min_q.pop() def top(self): \"\"\" :rtype: int \"\"\" return self.stack[-1] def getMin(self): \"\"\" :rtype: int \"\"\" return self.min_q[-1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin()","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"160. Intersection of Two Linked Lists","slug":"intersection-of-two-linked-lists","date":"2017-03-16T09:18:58.000Z","updated":"2017-03-16T09:23:21.000Z","comments":true,"path":"2017/03/16/intersection-of-two-linked-lists/","link":"","permalink":"http://faramita.us/2017/03/16/intersection-of-two-linked-lists/","excerpt":"","text":"DescriptionDifficulty: Easy Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 â†’ a2 â†˜ c1 â†’ c2 â†’ c3 â†—B: b1 â†’ b2 â†’ b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. é¢˜æ„:ä¸¤ä¸ªé“¾è¡¨ï¼Œè¦æ±‚è¿”å›äº¤å‰ç‚¹ã€‚ Solutionå…ˆéå†ä¸€éï¼Œç¡®å®šäºŒè€…çš„é•¿åº¦ã€‚ä»è¾ƒé•¿çš„ä¸€ä¸ªå¼€å§‹éå†ï¼Œç›´åˆ°äºŒè€…é•¿åº¦ç›¸åŒï¼Œç„¶åä¸¤ä¸ªé“¾è¡¨åŒæ—¶å‘åéå†ï¼Œæ£€æµ‹æ¯ä¸€ä¸ªç‚¹æ˜¯ä¸æ˜¯ç‚¹æ˜¯ä¸æ˜¯ç›¸ç­‰éå†ä¸¤æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ O(n),ï¼›æ–°å»ºå››ä¸ªæŒ‡é’ˆï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" pt_a, pt_b = headA, headB len_a, len_b = 0, 0 while pt_a: len_a += 1 pt_a = pt_a.next while pt_b: len_b += 1 pt_b = pt_b.next if len_a &gt; len_b: long, short = headA, headB else: long, short = headB, headA for diff in range(abs(len_a - len_b)): long = long.next common = None while long: if long == short: common = long break else: long, short = long.next, short.next return common","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"14. Longest Common Prefix","slug":"longest-common-prefix","date":"2017-03-16T09:02:11.000Z","updated":"2017-03-16T09:05:15.000Z","comments":true,"path":"2017/03/16/longest-common-prefix/","link":"","permalink":"http://faramita.us/2017/03/16/longest-common-prefix/","excerpt":"","text":"DescriptionDifficulty: Easy Write a function to find the longest common prefix string amongst an array of strings. é¢˜æ„:ç»™å‡ºä¸€ listï¼Œå†…å®¹ä¸ºä¸€äº›å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºè¿™äº›å­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚ Solutionå…ˆå°†å‰ç¼€ prefix å®šä½ list çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚å¯¹äºä¹‹åçš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœè¯¥å…ƒç´ æ¯” prefix çŸ­ï¼Œåˆ™å…ˆå°† prefix åˆ‡æˆç›¸åº”é•¿åº¦ã€‚ç„¶åå¯¹æ¯” prefix ä¸å½“å‰å…ƒç´ ï¼Œé‡åˆ°ä¸åŒåˆ™å°† prefix åˆ‡æˆä¸åŒç‚¹ä¹‹å‰çš„éƒ¨åˆ†ã€‚ 12345678910111213141516171819202122232425class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if strs == []: return '' elif len(strs) == 1: return strs[0] prefix = strs[0] for s in strs[1:]: if s == '' or prefix == '': return '' prefix = prefix[:min(len(prefix), len(s))] for posi in range(len(prefix)): if prefix[posi] != s[posi]: prefix = prefix[:posi] break if len(prefix) == 0: return '' return prefix","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"88. Merge Sorted Array","slug":"merge-sorted-array","date":"2017-03-16T08:31:03.000Z","updated":"2017-03-16T08:34:38.000Z","comments":true,"path":"2017/03/16/merge-sorted-array/","link":"","permalink":"http://faramita.us/2017/03/16/merge-sorted-array/","excerpt":"","text":"DescriptionDifficulty: Easy Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. é¢˜æ„:ç»™ä¸¤ä¸ªæœ‰åºæ•°ç»„ nums1ã€nums2ï¼Œå°†ä¸¤ä¸ªæ•°ç»„åŸåœ°åˆå¹¶åˆ° nums1ï¼Œä¿æŒ nums1 æœ‰åºã€‚ Solutionä¸å½’å¹¶æ’åºç±»ä¼¼ï¼Œä½†æ˜¯ä»å¤´éƒ¨å¼€å§‹å½’å¹¶çš„æˆæœ¬å¤ªé«˜ï¼Œè€Œ nums1 åˆæœ‰è¶³å¤Ÿçš„é•¿åº¦ï¼Œå› æ­¤ä»ä¸¤æ•°ç»„çš„å°¾éƒ¨å¼€å§‹å½’å¹¶ï¼Œæ”¾åœ¨ nums1 å°¾éƒ¨ï¼ˆä» m + n - 1 å¼€å§‹ï¼‰ã€‚ 1234567891011121314151617181920212223242526class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" if n == 0: return p1, p2 = m - 1, n - 1 # 2 working pointers init at the ends for i in range(m + n - 1, -1, -1): if p1 &lt; 0: nums1[i] = nums2[p2] p2 -= 1 elif p2 &lt; 0: nums1[i] = nums1[p1] p1 -= 1 elif nums1[p1] &gt; nums2[p2]: nums1[i] = nums1[p1] p1 -= 1 elif nums1[p1] &lt;= nums2[p2]: nums1[i] = nums2[p2] p2 -= 1","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"234. Palindrome Linked List","slug":"palindrome-linked-list","date":"2017-03-14T08:18:22.000Z","updated":"2017-03-14T08:20:39.000Z","comments":true,"path":"2017/03/14/palindrome-linked-list/","link":"","permalink":"http://faramita.us/2017/03/14/palindrome-linked-list/","excerpt":"","text":"DescriptionDifficulty: Easy Given a singly linked list, determine if it is a palindrome. Follow up:Could you do it in O(n) time and O(1) space? é¢˜æ„:åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦å›æ–‡ã€‚ Solutionæœ€ç®€å•çš„æƒ³æ³•æ˜¯æŠŠé“¾è¡¨çš„å€¼æŒ‰é¡ºåºè¾“å‡ºåˆ°ä¸€ä¸ªæ•°ç»„ï¼Œåœ¨åˆ¤æ–­æ•°ç»„æ˜¯å¦å›æ–‡ï¼›åˆ¤æ–­æ•°ç»„æ˜¯å¦å›æ–‡ï¼Œä¹Ÿå°±æ˜¯åˆ¤æ–­å‰ä¸€åŠçš„é€†åºæ˜¯å¦ä¸åä¸€åŠç›¸ç­‰ã€‚ 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if not head: return True link_list = [] p = head while p: link_list.append(p.val) p = p.next length = len(link_list) if length % 2 == 0: return link_list[:(length / 2)] == link_list[(length / 2):][::-1] else: return link_list[:(length / 2)] == link_list[(length / 2) + 1:][::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"412. Fizz Buzz","slug":"fizz-buzz","date":"2017-03-14T07:38:00.000Z","updated":"2017-03-14T07:38:35.000Z","comments":true,"path":"2017/03/14/fizz-buzz/","link":"","permalink":"http://faramita.us/2017/03/14/fizz-buzz/","excerpt":"","text":"DescriptionDifficulty: Easy Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output â€œFizzâ€ instead of the number and for the multiples of five output â€œBuzzâ€. For numbers which are multiples of both three and five output â€œFizzBuzzâ€. Examplen = 15, Return:[ â€œ1â€, â€œ2â€, â€œFizzâ€, â€œ4â€, â€œBuzzâ€, â€œFizzâ€, â€œ7â€, â€œ8â€, â€œFizzâ€, â€œBuzzâ€, â€œ11â€, â€œFizzâ€, â€œ13â€, â€œ14â€, â€œFizzBuzzâ€] Solution123456789101112131415161718class Solution(object): def fizzBuzz(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" rslt = [] for i in xrange(n): if (i + 1) % 15 == 0: rslt.append('FizzBuzz') elif (i + 1) % 5 == 0: rslt.append('Buzz') elif (i + 1) % 3 == 0: rslt.append('Fizz') else: rslt.append(str(i + 1)) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"20. Valid Parentheses","slug":"valid-parentheses","date":"2017-03-14T06:35:45.000Z","updated":"2017-03-14T06:41:31.000Z","comments":true,"path":"2017/03/14/valid-parentheses/","link":"","permalink":"http://faramita.us/2017/03/14/valid-parentheses/","excerpt":"","text":"DescriptionDifficulty: Easy Given a string containing just the characters â€˜(â€˜, â€˜)â€™, â€˜{â€˜, â€˜}â€™, â€˜[â€˜ and â€˜]â€™, determine if the input string is valid. The brackets must close in the correct order, â€œ()â€ and â€œ()[]{}â€ are all valid but â€œ(]â€ and â€œ([)]â€ are not. é¢˜æ„:è¾“å…¥ä¸€åˆ—æ‹¬å·ç»„åˆï¼Œæ•°å‡ºæ˜¯å¦åˆæ³•ï¼Œå³æ‹¬å·æ˜¯å¦å…ˆæ‰“å¼€åå…³é—­å¹¶ä¸”ä»¥æ­£ç¡®é¡ºåºå…³é—­ã€‚ Solutionå®é™…ä¸Šå°±æ˜¯å®ç°ä¸€ä¸ª stackã€‚è¿™é‡Œä½¿ç”¨ dict ç±»å‹æ¥åˆ¤æ–­å·¦å³æ‹¬å·æ˜¯å¦å¯¹åº”ã€‚ 123456789101112131415161718192021222324class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" left = &#123;'(': 0, '[': 1, '&#123;': 2&#125; # left dict right = &#123;')': 0, ']': 1, '&#125;': 2&#125; # right dict stack = [] # working stack for i in s: # every element in s if i in left: # if it's one of the lefts stack.append(i) # stack push elif i in right: # if it's one of the rights try: # try to pop tmp = stack.pop() except IndexError: # if nothing to pop, return False return False if left[tmp] != right[i]: # if they do not match, return False return False if stack == []: # stack must be empty return True else: return False","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"38. Count and Say","slug":"count-and-say","date":"2017-03-14T06:23:48.000Z","updated":"2017-03-14T06:26:36.000Z","comments":true,"path":"2017/03/14/count-and-say/","link":"","permalink":"http://faramita.us/2017/03/14/count-and-say/","excerpt":"","text":"DescriptionDifficulty: Easy The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, â€¦ 1 is read off as â€œone 1â€ or 11.11 is read off as â€œtwo 1sâ€ or 21.21 is read off as â€œone 2, then one 1â€ or 1211. Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. é¢˜æ„:æœ‰è¿™æ ·ä¸€ä¸ªæ•°åˆ—ï¼Œä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯ç”±ä¸Šä¸€ä¸ªå…ƒç´ æŒ‰ç…§ï¼ˆå…ƒç´ ä¸ªæ•°ï¼Œå…ƒç´ ï¼‰çš„æ–¹æ³•ç»„æˆçš„ã€‚æ±‚è¿™ä¸ªæ•°åˆ—çš„ç¬¬ n ä¸ªå…ƒç´ ã€‚ Solutionè¿­ä»£ï¼šæŠŠæ•°åˆ—çš„ä¸Šä¸€ä¸ªå…ƒç´ åœ¨å…ƒç´ å˜åŒ–çš„ç‚¹åˆ‡åˆ†ï¼Œç„¶åæ•°å‡ºæ¯ä¸€å—çš„é•¿åº¦å³å¯ã€‚_loop å‡½æ•°ç”¨æ¥è¿­ä»£ã€‚ 1234567891011121314151617181920212223242526272829303132333435def _loop(s): if len(s) == 1: return '11' head, tail = 1, 0 rslt = [] rslt_s = '' scanning = False while max(head, tail) &lt; len(s): if s[head] == s[tail] and not scanning: scanning = True elif s[head] != s[tail]: rslt.append(s[tail:head]) tail = head if scanning: scanning = False head += 1 # if scanning: rslt.append(s[tail:]) for sub in rslt: rslt_s = rslt_s + str(len(sub)) + sub[0] return rslt_sclass Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" rslt = '1' for i in range(1, n): rslt = _loop(rslt) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"172. Factorial Trailing Zeroes","slug":"factorial-trailing-zeroes","date":"2017-03-14T04:47:28.000Z","updated":"2017-03-14T04:50:04.000Z","comments":true,"path":"2017/03/14/factorial-trailing-zeroes/","link":"","permalink":"http://faramita.us/2017/03/14/factorial-trailing-zeroes/","excerpt":"","text":"DescriptionDifficulty: Easy Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. é¢˜æ„:æ•°è¾“å…¥æ•°å­—çš„é˜¶ä¹˜çš„æœ«å°¾ç”±å¤šå°‘ä¸ª 0ã€‚ Solutionæ¯ä¸ª 0 éƒ½æ˜¯ç”± 2 * 5 æä¾›çš„ã€‚ä½†æ˜¯ç”±äº å¶æ•°ä¼—å¤šï¼Œå› æ­¤ 2 æ€»æ˜¯è¶³å¤Ÿçš„ï¼›åŒæ—¶æœ‰äº›æ•°å­—ä¸­åŒ…å«å¤šä¸ª 5ï¼ˆå¦‚ 25ï¼‰ï¼Œæ•…éœ€è¦å¤šæ¬¡é‡å¤ç›´åˆ°æ•°å­—ä¸­ä¸å« 5ã€‚ 1234567891011class Solution(object): def trailingZeroes(self, n): \"\"\" :type n: int :rtype: int \"\"\" zeros = 0 while n &gt; 0: n /= 5 zeros += n return zeros","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"344. Reverse String","slug":"reverse-string","date":"2017-03-14T03:28:00.000Z","updated":"2017-03-14T07:40:34.000Z","comments":true,"path":"2017/03/14/reverse-string/","link":"","permalink":"http://faramita.us/2017/03/14/reverse-string/","excerpt":"","text":"DescriptionDifficulty: Easy Write a function that takes a string as input and returns the string reversed. Example1Given s = â€œhelloâ€, return â€œollehâ€. åè½¬å­—ç¬¦ä¸²ã€‚ Solution1234567class Solution(object): def reverseString(self, s): \"\"\" :type s: str :rtype: str \"\"\" return s[::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"4. Median of Two Sorted Arrays","slug":"median-of-two-sorted-arrays","date":"2017-03-14T03:28:00.000Z","updated":"2017-03-14T07:39:51.000Z","comments":true,"path":"2017/03/14/median-of-two-sorted-arrays/","link":"","permalink":"http://faramita.us/2017/03/14/median-of-two-sorted-arrays/","excerpt":"","text":"DescriptionDifficulty: Hard There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example1nums1 = [1, 3]nums2 = [2] The median is 2.0 Example2nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 ç»™å‡ºä¸¤ä¸ªæœ‰åºæ•°åˆ—ï¼Œè¿”å›ä¸¤ä¸ªæ•°åˆ—å½¢æˆçš„å¤§æ•°åˆ—çš„ä¸­ä½æ•°ã€‚ Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" # pointers for two lists p1 = 0 p2 = 0 isOdd = True # last nums last = 0 if (len(nums1) + len (nums2)) % 2 == 1: exp_num = (len(nums1) + len (nums2) + 1) / 2 isOdd = True else: exp_num = ((len(nums1) + len (nums2)) / 2) + 1 isOdd = False if len(nums1) == 0 or len(nums2) == 0: comb = nums1 + nums2 if isOdd == True: return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) elif nums1[-1] &lt;= nums2[0]: comb = nums1 + nums2 if isOdd == True: return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) elif nums2[-1] &lt;= nums1[0]: comb = nums2 + nums1 if isOdd == True: print(comb[exp_num]) return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) while p1 + p2 &lt;= exp_num - 2: if p1 &gt;= len(nums1): last = nums2[p2] p2 += 1 elif p2 &gt;= len(nums2): last = nums1[p1] p1 += 1 elif nums1[p1] &lt; nums2[p2]: last = nums1[p1] p1 += 1 else: last = nums2[p2] p2 += 1 if p1 &gt;= len(nums1): toAdd = nums2[p2] elif p2 &gt;= len(nums2): toAdd = nums1[p1] else: toAdd = min(nums1[p1], nums2[p2]) if isOdd == True: return toAdd else: return (toAdd + last) / float(2)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"136. Single Number","slug":"single-number","date":"2017-03-14T03:28:00.000Z","updated":"2017-03-14T07:41:50.000Z","comments":true,"path":"2017/03/14/single-number/","link":"","permalink":"http://faramita.us/2017/03/14/single-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? ç»™å‡ºä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæœ‰ä¸€ä¸ªå…ƒç´ åªå‡ºç°äº†ä¸€æ¬¡ï¼Œå…¶ä»–æ‰€æœ‰å…ƒç´ éƒ½å‡ºç°äº†ä¸¤æ¬¡ã€‚æ‰¾å‡ºè¿™ä¸ªå…ƒç´ ã€‚ Solution123456789101112131415class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" rslt = &#123;&#125; for i in nums: try: rslt[i] += 1 except KeyError: rslt[i] = 1 for j in rslt: if rslt[j] == 1: return j","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"26. Remove Duplicates from Sorted Array","slug":"remove-duplicates-from-sorted-array","date":"2017-03-13T17:09:00.000Z","updated":"2017-03-14T02:39:32.000Z","comments":true,"path":"2017/03/14/remove-duplicates-from-sorted-array/","link":"","permalink":"http://faramita.us/2017/03/14/remove-duplicates-from-sorted-array/","excerpt":"","text":"DescriptionDifficulty: Easy Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesnâ€™t matter what you leave beyond the new length. é¢˜æ„:åŸåœ°ä¸ºä¸€ä¸ªæ•°ç»„å»é‡ï¼Œè¿”å›ä¸é‡å¤çš„æ•°ç»„é•¿åº¦ n å¹¶ä¸”ä»…éœ€ä¿æŒè¯¥æ•°ç»„å‰ n ä½ä¸ºä¸é‡å¤çš„æ•°ç»„ã€‚ Solutionè™½ç„¶æ•ˆç‡åä½ï¼Œä½†æ˜¯é‡å¤çš„åˆ æ‰å°±å¥½ã€‚ 123456789101112131415161718192021222324class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt;= 1: return len(nums) elif len(nums) == 2: if nums[0] == nums[1]: return 1 else: return 2 # now,it has at least the length of 3 i = 1 while i &lt; len(nums): # if nums[tail] != nums[i]: # tail += 1 if nums[i-1] == nums[i]: del(nums[i]) else: i += 1 return len(nums) updateï¼šè®¨è®ºä¸­å±•ç¤ºäº†ä¸€ç§ç®€æ´è€Œä¼˜ç¾çš„å†™æ³•ï¼š123456789101112131415class Solution: # @param a list of integers # @return an integer def removeDuplicates(self, A): if not A: return 0 newTail = 0 for i in range(1, len(A)): if A[i] != A[newTail]: newTail += 1 A[newTail] = A[i] return newTail + 1 ä¹Ÿå°±æ˜¯å°†æ¯ä¸€ä¸ªä¸åŒçš„å…ƒç´ å¤åˆ¶åˆ° newTail ä½ç½®ã€‚","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"118. Pascal's Triangle","slug":"pascals-triangle","date":"2017-03-13T15:31:29.000Z","updated":"2017-03-13T15:32:54.000Z","comments":true,"path":"2017/03/13/pascals-triangle/","link":"","permalink":"http://faramita.us/2017/03/13/pascals-triangle/","excerpt":"","text":"DescriptionDifficulty: Easy Given numRows, generate the first numRows of Pascalâ€™s triangle. For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] é¢˜æ„:ç»™å‡ºè¡Œæ•°ï¼Œç”Ÿæˆç›¸åº”è¡Œå¸•æ–¯å¡ä¸‰è§’ã€‚ Solutionå¸•æ–¯å¡ä¸‰è§’çš„ä¸‹ä¸€è¡Œçš„æŸå…ƒç´ æ˜¯ä¸Šä¸€è¡Œçš„ç›¸é‚»ä¸¤å…ƒç´ çš„å’Œã€‚ 123456789101112131415161718192021class Solution(object): def generate(self, numRows): \"\"\" :type numRows: int :rtype: List[List[int]] \"\"\" if numRows == 0: rslt = [] elif numRows == 1: rslt = [[1]] elif numRows == 2: rslt = [[1], [1, 1]] elif numRows &gt; 2: rslt = [[1], [1, 1]] for i in xrange(2, numRows): now = [1] for j in xrange(1, i): now.append(rslt[i-1][j-1] + rslt[i-1][j]) now.append(1) rslt.append(now) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"66. Plus One","slug":"plus-one","date":"2017-03-13T15:13:18.000Z","updated":"2017-03-14T02:35:13.000Z","comments":true,"path":"2017/03/13/plus-one/","link":"","permalink":"http://faramita.us/2017/03/13/plus-one/","excerpt":"","text":"DescriptionDifficulty: Easy Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. é¢˜æ„:ç»™ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ è¡¨ç¤ºä¸€ä¸ªæ•°å­—çš„æ¯ä¸€ä½ï¼Œè¦æ±‚ä»¥ç›¸åŒå½¢å¼ç»™å‡ºè¿™ä¸ªæ•°å­—åŠ ä¸€çš„ç»“æœã€‚ Solutionéš¾ç‚¹åœ¨äºè¿›ä½ï¼Œç‰¹åˆ«æ˜¯ç”± n ä½æ•°å˜ä¸º n + 1 ä½æ•°æ—¶ï¼Œå¦‚æœæ¯ä¸€ä½éƒ½ç§»åŠ¨ä»£ä»·å¤ªå¤ªã€‚è¿™é‡Œå…ˆå°†æ•°ç»„é€†ç½®ï¼Œç„¶åä»å¤´éƒ¨ï¼ˆå³æœ«ä½ï¼‰åŠ ä¸€ï¼Œè¿›ä½å®Œæˆååœ¨é€†ç½®å›æ¥ã€‚ 123456789101112131415161718class Solution(object): def plusOne(self, digits): \"\"\" :type digits: List[int] :rtype: List[int] \"\"\" digits_r = digits[::-1] added = False for i in xrange(len(digits)): if digits_r[i] + 1 &lt; 10: digits_r[i] += 1 added = True break elif digits_r[i] + 1 == 10: digits_r[i] = 0 if added == False: digits_r.append(1) return digits_r[::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"ä¸€ä¸ªäº¤ä½œä¸šçš„å°å·¥å…· v2.1","slug":"a-tool-for-homework-v2.1","date":"2017-03-13T11:40:32.000Z","updated":"2017-03-13T11:43:39.000Z","comments":true,"path":"2017/03/13/a-tool-for-homework-v2.1/","link":"","permalink":"http://faramita.us/2017/03/13/a-tool-for-homework-v2.1/","excerpt":"","text":"update:ç½‘é¡µç»“æ„ç¨æœ‰å˜åŒ–ï¼Œä¿®æ”¹ä»¥é€‚åº”ï¼›æ–‡ä»¶åè·å–æ–¹å¼æ›´åŠ å¯é ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: UTF-8 -*-import sysimport timefrom pyquery import PyQuery as pqtmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**&#123;contents&#125;&lt;b&gt;é¢˜æ„:&lt;/b&gt;&lt;br&gt;## Solution&#123;% codeblock lang:text %&#125;&#123;% endcodeblock %&#125;'''url = sys.argv[1]d = pq(url)get_title = d('.question-title h3').text()get_difficulty = d('.question-info li strong').eq(2).text()get_filename = url.lstrip('https://').split('/')[2] + '.md'get_contents = (d('.question-content').html(method='html') .split('&lt;p&gt;&lt;a href=\"/subscribe/\"&gt;Subscribe&lt;/a&gt;')[0].rstrip().rstrip('&lt;div&gt;') .split('&lt;p&gt;&lt;b&gt;Credits:&lt;/b&gt;')[0].strip())tmp = tmp.format( title=get_title, difficulty=get_difficulty, contents=get_contents, date=time.strftime(\"%F %H:%M:%S\", time.localtime()))file = open(get_filename, 'w')file.write(tmp)file.close()# call(['vim', get_filename])print('Show time:\\n', get_filename) äººç”Ÿè‹¦çŸ­ï¼Œæˆ‘ç”¨ Pythonã€‚","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"101. Symmetric Tree","slug":"symmetric-tree","date":"2017-03-13T11:20:39.000Z","updated":"2017-03-13T15:16:25.000Z","comments":true,"path":"2017/03/13/symmetric-tree/","link":"","permalink":"http://faramita.us/2017/03/13/symmetric-tree/","excerpt":"","text":"DescriptionDifficulty: Easy Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3Note:Bonus points if you could solve it both recursively and iteratively. é¢˜æ„ï¼šè¾“å…¥ä¸€æ£µäºŒå‰æ ‘ï¼Œåˆ¤æ–­æ˜¯å¦çºµå‘è½´å¯¹ç§°ï¼ˆä¸é•œåƒç›¸åŒï¼‰ã€‚ Solutionåªéœ€è¦åˆ¤æ–­è·ŸèŠ‚ç‚¹çš„å·¦å³å­æ ‘æ˜¯å¦é•œåƒå¯¹ç§°ã€‚ä¹Ÿå°±æ˜¯è¯´åªéœ€è¦åˆ¤æ–­å³å­æ ‘ç¿»è½¬åæ˜¯å¦ä¸å·¦å­æ ‘ç›¸åŒå³å¯ã€‚ä¹Ÿå°±æ˜¯ä»¥ç›¸åŒæ–¹å¼éå†å·¦å­æ ‘ä¸ç¿»è½¬åçš„å³å­æ ‘ï¼Œç”Ÿæˆçš„å€¼çš„æ•°ç»„ç›¸åŒå³å¯ã€‚ æ–¹æ³• revrs_bt ç”¨äºåè½¬äºŒå‰æ ‘ï¼›æ–¹æ³• mlr_walk ç”¨äºå‰åºéå†äºŒå‰æ ‘ï¼›è¿”å›ç”Ÿæˆçš„ä¸¤æ•°ç»„æ˜¯å¦ç›¸ç­‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Nonedef revrs_bt(node): head = node if node: node.left, node.right = revrs_bt(node.right), revrs_bt(node.left) return headdef mlr_walk(rslt, node): if node: rslt.append(node.val) try: mlr_walk(rslt, node.left) except AttributeError: rslt.append(None) try: mlr_walk(rslt, node.right) except AttributeError: rslt.append(None) return rsltclass Solution(object): def isSymmetric(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" if root == None or (root.left, root.right) == (None, None): return True t_l = root.left # left tree t_r = root.right # right tree t_r_r = revrs_bt(t_r) # reversed right tree rslt_l, rslt_r = [], [] rslt_l = mlr_walk(rslt_l, t_l) rslt_r = mlr_walk(rslt_r, t_r_r) return rslt_l == rslt_r","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"198. House Robber","slug":"house-robber","date":"2017-03-13T04:30:07.000Z","updated":"2017-03-13T04:41:54.000Z","comments":true,"path":"2017/03/13/house-robber/","link":"","permalink":"http://faramita.us/2017/03/13/house-robber/","excerpt":"","text":"DescriptionDifficulty: Easy You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯è¿™å®¶è—çš„é’±ï¼Œä¸èƒ½è¿ç»­æŠ¢ä¸¤å®¶çš„é’±ï¼Œè¦æ±‚æŠ¢åˆ°å°½é‡å¤šçš„é’±ï¼Œæ±‚èƒ½æŠ¢åˆ°çš„æœ€å¤šçš„é’±æ•°ã€‚ Solutionåˆä¸€é“åŠ¨æ€è§„åˆ’çš„é—®é¢˜ï¼Œå½“æ•°ç»„éå†è‡³ i ä½ç½®æ—¶ï¼Œpre2 è¡¨ç¤º i - 2 ä½ç½®çš„å’Œ, pre1 è¡¨ç¤º i - 1 ä½ç½®çš„å’Œ, curr ç”¨äºä¿å­˜æœ¬è½®ç»“æœã€‚å¯¹äºæ¯ä¸ª iï¼ˆi &gt; 3ï¼‰éƒ½è¦åšå‡ºè¿™æ ·ä¸€ä¸ªé€‰æ‹©ï¼šè¦ pre2 + nums[i] è¿˜æ˜¯è¦ pre1. 123456789101112131415161718192021class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) prev1,prev2,curr = 0, 0, 0 for i in nums: curr = max(i + prev2, prev1); prev2 = prev1; prev1 = curr; return curr","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"70. Climbing Stairs","slug":"climbing-stairs","date":"2017-03-10T02:00:59.000Z","updated":"2017-03-10T02:04:56.000Z","comments":true,"path":"2017/03/10/climbing-stairs/","link":"","permalink":"http://faramita.us/2017/03/10/climbing-stairs/","excerpt":"","text":"DescriptionDifficulty: Easy You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. n é˜¶æ¥¼æ¢¯ï¼Œæ¯æ¬¡å¯ä»¥çˆ¬ä¸€é˜¶æˆ–è€…ä¸¤é˜¶ï¼Œé—®æœ‰å¤šå°‘ç§æ–¹æ³•ã€‚ Solutionç”±äºåŒ…å«åŠ¨æ€è§„åˆ’çš„ä¸¤ä¸ªç‰¹å¾ï¼š æœ€ä¼˜å­ç»“æ„ é‡å¤çš„å­é—®é¢˜ å› æ­¤å¯ç”¨åŠ¨æ€è§„åˆ’ã€‚ æ ¸å¿ƒç®—æ³•ï¼šä¸ºäº†åˆ°è¾¾ç¬¬ i é˜¶ï¼ˆi &gt;= 3)ï¼Œå¯ä»¥ä» i - 1 é˜¶ä¸Šä¸€é˜¶ï¼Œä¹Ÿå¯ä»¥ä» i - 2 é˜¶ä¸Šä¸¤é˜¶ã€‚é€’å½’è¿™ä¸ªç®—æ³•å³å¯ã€‚ 1234567891011class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\" stor = &#123;1: 1, 2: 2&#125; for i in xrange(3, n+1): stor[i] = stor[i-1] + stor[i-2] return stor[n]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"ä¸€ä¸ªäº¤ä½œä¸šçš„å°å·¥å…· v2.0","slug":"a-tool-for-homework-v2","date":"2017-03-08T13:32:32.000Z","updated":"2017-03-12T06:05:59.000Z","comments":true,"path":"2017/03/08/a-tool-for-homework-v2/","link":"","permalink":"http://faramita.us/2017/03/08/a-tool-for-homework-v2/","excerpt":"","text":"æœ¬ç‰ˆå°†å‚æ•°å‡å°‘åˆ°ä¸€ä¸ªï¼šé¢˜ç›®çš„ URLã€‚ä¹‹åè‡ªåŠ¨è·å–æ–‡ä»¶åã€æ ‡é¢˜ã€æè¿°ã€éš¾åº¦ç­‰ç­‰ï¼Œåªéœ€å¡«å†™é¢˜ç›®è§£é‡Šã€è§£é¢˜æ€è·¯ä¸ä»£ç ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/python# -*- coding: UTF-8 -*-import sysimport timefrom pyquery import PyQuery as pqtmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**&#123;contents&#125;## Solution&#123;% codeblock lang:text %&#125;&#123;% endcodeblock %&#125;'''url = sys.argv[1]d = pq(url)get_title = d('.question-title h3').text()get_difficulty = d('#DescriptionContent .question-info li strong').eq(2).text()get_filename = url.rstrip('?tab=Description').rstrip('/').split('/')[-1] + '.md'get_contents = (d('.question-content') .html(method='html') .split('&lt;div&gt;&lt;p&gt;&lt;a href=\"/subscribe/\"&gt;Subscribe&lt;/a&gt;')[0] .split('&lt;p&gt;&lt;b&gt;Credits:&lt;/b&gt;')[0] .strip())tmp = tmp.format( title=get_title, difficulty=get_difficulty, contents=get_contents, date=time.strftime(\"%F %H:%M:%S\", time.localtime()))file = open(get_filename, 'w')file.write(tmp)file.close()print('Show time:', get_filename) ä¸‹ä¸€ç‰ˆæ‰“ç®—å®ç°è¾“å…¥é¢˜å·ä»£æ›¿ç½‘å€ã€‚ äººç”Ÿè‹¦çŸ­ï¼Œæˆ‘ç”¨ Pythonã€‚","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"202. Happy Number","slug":"happy-number","date":"2017-03-08T13:27:07.000Z","updated":"2017-03-08T13:35:01.000Z","comments":true,"path":"2017/03/08/happy-number/","link":"","permalink":"http://faramita.us/2017/03/08/happy-number/","excerpt":"","text":"DescriptionDifficulty: Easy Write an algorithm to determine if a number is â€œhappyâ€. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 è¿”å›è¾“å…¥æ•°å­—æ˜¯å¦æ˜¯ã€Œå¿«ä¹æ•°ã€ï¼Œå³é‡å¤è®¡ç®—å„ä½æ•°å­—å¹³æ–¹å’Œï¼Œå¦‚æœæœ€ç»ˆç­‰äº 1 åˆ™ã€Œå¿«ä¹ã€ã€‚ Solutioné€’å½’è¿ç®—ï¼Œç›´åˆ°ç®—å‡ºä¸€ä½æ•°ç»“æœã€‚ä¸€ä½æ•°ä¸­åªæœ‰ 1ï¼Œ7 æ»¡è¶³æ¡ä»¶ã€‚ä¸ºäº†å‡å°‘è®¡ç®—é‡ï¼Œç›´æ¥åˆ å»æ•°å­—ä¸­çš„ 0ã€‚ 1234567891011121314151617181920212223242526def happy(n): if n &lt;= 0: return False sum = 0 if n &lt;= 10: if n == 1 or n == 7 or n == 10: return True else: return False # return False elif n &gt; 10: s = str(n).strip('0') for i in s: sum += (int(i) ** 2) return happy(sum)class Solution(object): def isHappy(self, n): \"\"\" :type n: int :rtype: bool \"\"\" return happy(n)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"ä¸€ä¸ªäº¤ä½œä¸šçš„å°å·¥å…·","slug":"a-tool-for-homework","date":"2017-03-08T08:58:32.000Z","updated":"2017-03-12T06:05:46.000Z","comments":true,"path":"2017/03/08/a-tool-for-homework/","link":"","permalink":"http://faramita.us/2017/03/08/a-tool-for-homework/","excerpt":"","text":"æœ¬åšå®¢åŸºäº Hexo æ­å»ºã€‚Hexo çš„æ–‡ç« æ ¼å¼è™½ç„¶ç®€å•ï¼Œä½†æ˜¯æ¯æ¬¡æ‰‹æ‰“ä¹Ÿå®åœ¨å¤ªéº»çƒ¦ã€‚æ•…å†™ä¸€å°è„šæœ¬å¸®åŠ©ç”Ÿæˆéœ€è¦çš„ä½œä¸šæ ¼å¼ã€‚ä¸‰ä¸ªå‚æ•°åˆ†åˆ«ä¸ºæ–‡ä»¶åï¼Œæ ‡é¢˜ä¸éš¾åº¦ï¼›é™¤æ­¤ä»¥å¤–è¿˜ä¼šè‡ªåŠ¨å¡«å……å½“å‰æ—¶é—´ã€‚ä»£ç å¦‚ä¸‹ã€‚ 12345678910111213141516171819202122232425262728293031#!/usr/bin/python3# -*- coding: UTF-8 -*-import sysimport timetmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**## Solution'''tmp = tmp.format( title=sys.argv[2], difficulty=sys.argv[3], date=time.strftime(\"%F %H:%M:%S\", time.localtime()))tmp += (r'&#123;% codeblock lang:python %&#125;' + '\\n\\n' + r'&#123;% endcodeblock %&#125;' + '\\n')file = open(sys.argv[1] + '.md', 'w')file.write(tmp)file.close()print(sys.argv[1] + '.md') ä¹‹åè¿˜ä¼šå¯¹ä¿¡æ¯å¡«å……è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œå¦‚ä»ç½‘é¡µè‡ªåŠ¨è·å–é—®é¢˜æè¿°ç­‰ã€‚ äººç”Ÿè‹¦çŸ­ï¼Œæˆ‘ç”¨ Pythonã€‚","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"121. Best Time to Buy and Sell Stock","slug":"best-time-to-buy-and-sell-stock","date":"2017-03-08T08:51:32.000Z","updated":"2017-03-08T08:56:32.000Z","comments":true,"path":"2017/03/08/best-time-to-buy-and-sell-stock/","link":"","permalink":"http://faramita.us/2017/03/08/best-time-to-buy-and-sell-stock/","excerpt":"","text":"DescriptionDifficulty: Easy Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. ç»™å‡ºä¸€æ•°ç»„ï¼Œä»£è¡¨æ¯å¤©çš„è‚¡ä»·ã€‚è¦æ±‚åªèƒ½ä¹°å–ä¸€æ¬¡ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦ã€‚ Solutionå®é™…ä¸Šæ˜¯æ±‚æ•°ç»„ä¸­åé¢çš„æ•°ä¸å‰é¢çš„æ•°çš„æœ€å¤§å·®å€¼ã€‚æœ€ç®€å•çš„æ–¹æ³•è‡ªç„¶æ˜¯ä¸¤ä¸ªå¾ªç¯ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦ä¸º O(n^2)ï¼Œå¾ˆä¸ç†æƒ³ã€‚ æ€è·¯ï¼šç”±äºåœ¨æ¯ä¸ªå•è°ƒåŒºé—´ä¸­å¯¹ç­”æ¡ˆæœ‰æ„ä¹‰çš„å…ƒç´ åªæœ‰åŒºé—´ä¸¤ç«¯çš„å€¼è€Œå·²ã€‚å› æ­¤æ„å»ºä¸¤ä¸ªæ–°æ•°ç»„ï¼Œåˆ†åˆ«åªåŒ…å«æ¯ä¸ªå•è°ƒåŒºé—´çš„æœ€å¤§å€¼ä¸æœ€å°å€¼ã€‚ä¹‹åï¼Œé’ˆå¯¹æœ€å°å€¼æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ ï¼Œæ‰¾æœ€å¤§å€¼æ•°ç»„ç›¸åº”ä½ç½®åŠä¹‹åçš„æœ€å¤§å…ƒç´ å³å¯ç®—å‡ºæœ€å¤§å·®å€¼ï¼ˆåˆ©æ¶¦ï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" max_profit = 0 if len(prices) == 2: return max(prices[1] - prices[0], 0) elif len(prices) &gt; 2: low = prices[0] high = prices[0] profit = 0 list_low = [prices[0]] list_high = [] up = True for i in xrange(len(prices) - 1): if prices[i + 1] &gt;= prices[i]: # going up high = prices[i + 1] if up == False: low = prices[i] list_low.append(low) up = True elif prices[i + 1] &lt; prices[i]: # going down low = prices[i + 1] if up == True: high = prices[i] list_high.append(high) up = False if len(list_high) &lt; len(list_low): list_high.append(prices[-1]) for j in xrange(len(list_low)): max_profit = max(max_profit, max(list_high[j:]) - list_low[j]) return max_profit","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"","slug":"sdsdsd","date":"2017-03-08T08:02:24.000Z","updated":"2017-03-08T08:03:21.000Z","comments":true,"path":"2017/03/08/sdsdsd/","link":"","permalink":"http://faramita.us/2017/03/08/sdsdsd/","excerpt":"","text":"example.md","categories":[],"tags":[]},{"title":"268. Missing Number","slug":"missing-number","date":"2017-03-07T12:46:00.000Z","updated":"2017-03-07T12:51:23.000Z","comments":true,"path":"2017/03/07/missing-number/","link":"","permalink":"http://faramita.us/2017/03/07/missing-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array containing n distinct numbers taken from 0, 1, 2, â€¦, n, find the one that is missing from the array. For example,Given nums = [0, 1, 3] return 2. Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? ç»™ä¸€æ•°ç»„ï¼Œç»™å‡ºæ•°ç»„ä¸ [0,1,2,3,4,â€¦,n] ç›¸æ¯”ç¼ºå°‘çš„ä¸€ä¸ªæ•°ã€‚æ‰€ç»™æ•°ç»„å¯ä¸ºä»»æ„é¡ºåºã€‚ Solutionå…ˆæ’åºã€‚åˆ†æä¸€ä¸‹æƒ…å†µï¼šæ•°ç»„é•¿åº¦ä¸º 0ï¼šç¼º 1æ•°ç»„é•¿åº¦ä¸º 1ï¼šæœ‰ä¸¤ç§æƒ…å†µï¼ˆå› ä¸ºåªèƒ½ç¼ºä¸€ä¸ªæ•°ï¼‰[0], [1]ï¼›åˆ†åˆ«è¿”å› 1, 0æ•°ç»„æ›´é•¿ï¼šè‹¥ç¬¬ä¸€ä¸ªå…ƒç´ ä¸æ˜¯ 0ï¼Œåˆ™è¿”å› 0ï¼›è®¾ä¸¤ä¸ªæŒ‡é’ˆä»å¼€å¤´éå†ï¼Œè‹¥åä¸€ä¸ªå‡å‰ä¸€ä¸ªå¤§äº 1ï¼Œåˆ™è¿”å›å‰ä¸€ä¸ª + 1ï¼›è‹¥ä¸€ç›´è¿ç»­ï¼Œè¿™è¿”å›æœ€åä¸€ä¸ªå…ƒç´  + 1 12345678910111213141516class Solution(object): def missingNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums.sort() if len(nums) == 0 or nums[0] != 0: return 0 elif nums == [0]: return 1 else: for i in xrange(len(nums) - 1): if nums[i + 1] - nums[i] &gt; 1: return nums[i] + 1 return nums[-1] + 1","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"350. Intersection of Two Arrays II","slug":"intersection-of-two-arrays-ii","date":"2017-03-07T12:26:00.000Z","updated":"2017-03-07T12:33:13.000Z","comments":true,"path":"2017/03/07/intersection-of-two-arrays-ii/","link":"","permalink":"http://faramita.us/2017/03/07/intersection-of-two-arrays-ii/","excerpt":"","text":"DescriptionDifficulty: Easy Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order. Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1â€™s size is small compared to nums2â€™s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? æ±‚ä¸¤ä¸ªæ•°ç»„äº¤é›†ã€‚ Solutioné‰´äºç»“æœçš„é¡ºåºä¸é™ï¼Œä¾ç„¶ä½¿ç”¨æˆ‘æœ€å–œæ¬¢çš„å­—å…¸ç±»å‹æ¥å®ç°ã€‚ï¼ˆå­—å…¸ç±»å‹å®é™…ä¸Šæ˜¯å“ˆå¸Œè¡¨ï¼Œå› æ­¤æ•ˆç‡å–œäººï¼‰å°†ä¸¤ä¸ªæ•°ç»„è½¬åŒ–ä¸ºå­—å…¸ï¼škeyï¼šæ•°ç»„ä¸­å…ƒç´ valueï¼šå…ƒç´ å‡ºç°æ¬¡æ•°ç„¶åæ ¹æ®è¾ƒçŸ­çš„å­—å…¸æ„å»ºæ•°ç»„ï¼šæ¯ä¸ªåœ¨çŸ­æ•°ç»„å‡ºç°è¿‡çš„å…ƒç´ ï¼Œè‹¥åœ¨é•¿æ•°ç»„ä¸­ä¹Ÿå­˜åœ¨ï¼Œåˆ™åœ¨ç»“æœæ•°ç»„ä¸­æ·»åŠ æ•°ä¸ªè¯¥å…ƒç´ ï¼Œæ·»åŠ çš„æ•°é‡ä¸ºè¯¥å…ƒç´ åœ¨ä¸¤ä¸ªå­—å…¸ä¸­å„è‡ªå‡ºç°æ¬¡æ•°ä¸­è¾ƒå°çš„ä¸€ä¸ªæ¬¡æ•°ã€‚ 12345678910111213141516171819202122232425262728def to_set(nums): nums_set = &#123;&#125; for i in nums: try: nums_set[i] += 1 except KeyError: nums_set[i] = 1 return nums_setclass Solution(object): def intersect(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" nums1_set = to_set(nums1) nums2_set = to_set(nums2) intersection = [] if len(nums1_set) &gt; len(nums2_set): nums1_set, nums2_set = nums2_set, nums1_set # 1 &lt; 2 for j in nums1_set: if j in nums2_set: intersection = intersection + ([j] * min(nums1_set[j], nums2_set[j])) return intersection","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"13. Roman to Integer","slug":"roman-to-integer","date":"2017-03-07T11:46:00.000Z","updated":"2017-03-07T11:51:39.000Z","comments":true,"path":"2017/03/07/roman-to-integer/","link":"","permalink":"http://faramita.us/2017/03/07/roman-to-integer/","excerpt":"","text":"DescriptionDifficulty: Easy Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. ç½—é©¬æ•°å­—è½¬æ¢ä¸ºé˜¿æ‹‰ä¼¯æ•°å­—ã€‚ Solutionä¸€é“å¾ˆæœ‰è¶£çš„é¢˜ã€‚æ ¹æ®ç½—é©¬æ•°å­—å·¦åŠ å³å‡çš„è§„åˆ™ï¼Œåœ¨å­—ç¬¦ä¸²é•¿åº¦å¤§äº 0 çš„æƒ…å†µä¸‹ï¼Œæ¯æ¬¡å–å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œè‹¥ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ IXC å…¶ä¸­ä¸€ä¸ªä¸”å°äºç¬¬äºŒä¸ªå…ƒç´ ï¼Œåˆ™æ€»å’ŒåŠ ç¬¬äºŒä¸ªå…ƒç´ å‡ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå­—ç¬¦ä¸²ä¿®æ”¹ä¸ºä»ç¬¬ä¸‰ä¸ªå…ƒç´ å¼€å§‹ï¼›è‹¥å­—ç¬¦ä¸²é•¿åº¦ä¸º 1 æˆ–ç¬¬ä¸€ä¸ªå…ƒç´ ä¸å°äºç¬¬äºŒä¸ªå…ƒç´ ï¼Œåˆ™æ€»å’ŒåŠ ä¸Šç¬¬ä¸€ä¸ªå…ƒç´ çš„å€¼ï¼Œå­—ç¬¦ä¸²ä»ç¬¬äºŒä¸ªå…ƒç´ å¼€å§‹ã€‚è¿”å›æ€»å’Œã€‚ 123456789101112131415161718192021class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" dict = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; sum = 0 while len(s) &gt; 0: if len(s) == 1: sum += dict[s[0]] s = s[1:] elif dict[s[0]] &lt; dict[s[1]] and s[0] in 'IXC': sum += (dict[s[1]] - dict[s[0]]) s = s[2:] else: sum += dict[s[0]] s = s[1:] return sum","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"242. Valid Anagram","slug":"valid-anagram","date":"2017-03-07T11:11:00.000Z","updated":"2017-03-07T11:13:12.000Z","comments":true,"path":"2017/03/07/valid-anagram/","link":"","permalink":"http://faramita.us/2017/03/07/valid-anagram/","excerpt":"","text":"DescriptionDifficulty: Easy Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = â€œanagramâ€, t = â€œnagaramâ€, return true.s = â€œratâ€, t = â€œcarâ€, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? åˆ¤æ–­ä¸¤ä¸ªè¯æ˜¯ä¸æ˜¯åŒå­—æ¯å¼‚æ„è¯ã€‚ Solutionç»´æŠ¤ä¸¤ä¸ªå­—å…¸ï¼škeyï¼šå­—ç¬¦ä¸²ä¸­çš„å…ƒç´ valueï¼šå…ƒç´ å‡ºç°çš„æ¬¡æ•° è¿”å›ä¸¤ä¸ªå­—å…¸æ˜¯å¦ç›¸ç­‰ 1234567891011121314151617def add_to_set(str): xSet = &#123;&#125; for i in str: try: xSet[i] += 1 except KeyError: xSet[i] = 1 return xSetclass Solution(object): def isAnagram(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" return add_to_set(s) == add_to_set(t)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"169. Majority Element","slug":"majority-element","date":"2017-03-07T10:55:00.000Z","updated":"2017-03-07T10:58:04.000Z","comments":true,"path":"2017/03/07/majority-element/","link":"","permalink":"http://faramita.us/2017/03/07/majority-element/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times. You may assume that the array is non-empty and the majority element always exist in the array. ç»™ä¸€æ•°åˆ—ï¼Œæ‰¾å‡ºä¼—æ•°ã€‚ Solutionæ‰«æä¸€é numsï¼Œç»´æŠ¤ä¸€ä¸ªå­—å…¸ xSetï¼škey ï¼šnums ä¸­å…ƒç´ valueï¼šè¯¥å…ƒç´ å‡ºç°æ¬¡æ•°å†æ‰«æä¸€é xSetï¼Œæ‰¾åˆ°å‡ºç°æ¬¡æ•°å¤§äº floor(len(nums)) çš„å…ƒç´ ï¼Œè¿”å›ã€‚ 1234567891011121314151617import mathclass Solution(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" xSet = &#123;&#125; for i in nums: try: xSet[i] += 1 except KeyError: xSet[i] = 1 for j in xSet: if xSet[j] &gt; math.floor(len(nums) / 2): return j","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"171. Excel Sheet Column Number","slug":"excel-sheet-column-number","date":"2017-03-06T17:04:00.000Z","updated":"2017-03-06T17:05:51.000Z","comments":true,"path":"2017/03/07/excel-sheet-column-number/","link":"","permalink":"http://faramita.us/2017/03/07/excel-sheet-column-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given a column title as appear in an Excel sheet, return its corresponding column number. Example A -&gt; 1 B -&gt; 2 C -&gt; 3 â€¦ Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 å°† Excel ä¸­ä½¿ç”¨å­—æ¯è¡¨ç¤ºçš„åˆ—å·è½¬æ¢ä¸ºæ•°å­—ã€‚ Solution26 è¿›åˆ¶è½¬æ¢ä¸º 10 è¿›åˆ¶ã€‚ 1234567891011class Solution(object): def titleToNumber(self, s): \"\"\" :type s: str :rtype: int \"\"\" column = 0 s_r = s[::-1] for i in xrange(len(s_r)): column += ((26 ** i) * (ord(s_r[i]) - 64)) return column","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"122. Best Time to Buy and Sell Stock II","slug":"best-time-to-buy-and-sell-stock-ii","date":"2017-03-06T16:38:00.000Z","updated":"2017-03-08T07:09:28.000Z","comments":true,"path":"2017/03/07/best-time-to-buy-and-sell-stock-ii/","link":"","permalink":"http://faramita.us/2017/03/07/best-time-to-buy-and-sell-stock-ii/","excerpt":"","text":"DescriptionDifficulty: Easy Say you have an array for which the i(th) element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). ç»™å‡ºä¸€ä¸ªæ•°åˆ—ï¼Œç¬¬ i ä¸ªä½ç½®ä»£è¡¨ç¬¬ i å¤©çš„è‚¡ä»·ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦ã€‚éšå«æ¡ä»¶æ˜¯æ¯æ¬¡ä¹°å–ä¸€è‚¡ï¼Œæœ¬é‡‘ä¸é™ã€‚ Solutionæ€è·¯ï¼šç‚’è‚¡çš„æ€è·¯å¾ˆç®€å•ï¼šé«˜ä¹°ä½å–ã€‚æœ¬é¢˜ç­‰äºæœ‰ä¸Šå¸è§†è§’ï¼Œé‚£ä¹ˆåªéœ€æ‰¾å‡ºæ‰€æœ‰å•è°ƒé€’å¢æ®µï¼Œæœ€ä½ç‚¹ä¹°å…¥æœ€é«˜ç‚¹å–å‡ºå³å¯ã€‚ å®šä¹‰å˜é‡ï¼šlowï¼šå½“å‰å•è°ƒé€’å¢å‘¨æœŸä¸­ä½ç‚¹ï¼›è‹¥ä½äºå•è°ƒé€’å‡å‘¨å‰åˆ™ä¸º Nonehighï¼šå½“å‰å•è°ƒé€’å¢å‘¨æœŸä¸­é«˜ç‚¹ï¼›profitï¼šç´¯è®¡åˆ©æ¶¦upï¼šæ ‡è®°æ˜¯å¦ä½äºå•è°ƒé€’å¢åŒºé—´ã€‚ æ‰«æä¸€éæ•°åˆ—ï¼šå¼€å§‹æ—¶é•¿åº¦å°äº 3 çš„åŸºæœ¬æƒ…å†µã€‚ æ•°åˆ—æ›´å¤§æ—¶ï¼šç»´æŠ¤å½“å‰å•è°ƒé€’å¢å‘¨æœŸçš„ low ä¸ highï¼›å½“å‰å•è°ƒé€’å¢å‘¨æœŸç»“æŸæ—¶ï¼ˆåä¸€å€¼å°äºå‰ä¸€å€¼ï¼‰ç»“ç®—ä¸€æ¬¡åˆ©æ¶¦ï¼ŒåŒæ—¶ up = Falseï¼Œlow = Noneé‡æ–°åˆ°è¾¾å•è°ƒé€’å¢åŒºé—´æ—¶é‡æ–°è®¾å®š low ä¸ºä½ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if len(prices) &lt;= 1: return 0 elif len(prices) == 2: return max(prices[1] - prices[0], 0) low = prices[0] high = prices[0] profit = 0 up = True for i in xrange(len(prices) - 1): if prices[i + 1] &gt;= prices[i]: # going up high = prices[i + 1] up = True if low == None: low = prices[i] elif prices[i + 1] &lt; prices[i]: if up == True: profit += (high - low) up = False low = None if up == True: profit += (high - low) return profit","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"387. First Unique Character in a String","slug":"first-unique-character-in-a-string","date":"2017-03-06T16:07:00.000Z","updated":"2017-03-06T16:38:37.000Z","comments":true,"path":"2017/03/07/first-unique-character-in-a-string/","link":"","permalink":"http://faramita.us/2017/03/07/first-unique-character-in-a-string/","excerpt":"","text":"DescriptionDifficulty: Easy Given a string, find the first non-repeating character in it and return itâ€™s index. If it doesnâ€™t exist, return -1. Examples = â€œleetcodeâ€return 0. s = â€œloveleetcodeâ€,return 2. NoteYou may assume the string contain only lowercase letters. æ‰¾åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­ä¸é‡å¤çš„å­—ç¬¦ï¼Œè¿”å›å…¶åœ¨å­—ç¬¦ä¸²ä¸­ä½ç½®ï¼Œå¦‚ä¸å­˜åœ¨åˆ™è¿”å› -1ã€‚ Solutionæ€è·¯ï¼šç»´æŠ¤ä¸€ä¸ªå­—å…¸ï¼Œé”®ä¸ºå­—ç¬¦ä¸²ä¸­å„ä¸ªå­—ç¬¦ï¼Œå€¼ä¸ºè¿™æ ·ä¸€ä¸ªæ•°ç»„ï¼š[è¯¥å­—ç¬¦å‡ºç°æ¬¡æ•°, è¯¥å­—ç¬¦é¦–æ¬¡å‡ºç°ä½ç½®]ã€‚æ‰«æä¸€éå­—ç¬¦ä¸²ï¼Œç»´æŠ¤å­—å…¸ï¼›æ‰«æä¸€éå­—å…¸ï¼Œç»´æŠ¤å‡ºç°æ¬¡æ•°ä¸º 1 çš„æœ€å°ä½ç½®ï¼Œè¿”å›è¿™ä¸ªå€¼ã€‚ 1234567891011121314151617181920212223242526class Solution(object): def firstUniqChar(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) == 0: return -1 setX = &#123;&#125; for i in xrange(len(s)): try: setX[s[i]][0] += 1 # setX[s[i]][1] = min(setX[s[i]][1], i) except KeyError: setX[s[i]] = [1, i] # (count, first time position) # print(setX) posi = -1 for j in setX: if setX[j][0] == 1: if posi == -1: posi = setX[j][1] elif posi &gt; 0: posi = min(setX[j][1], posi) return posi","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"7. Reverse Integer","slug":"string-to-integer-atoi","date":"2017-03-02T16:13:00.000Z","updated":"2017-03-02T16:13:56.000Z","comments":true,"path":"2017/03/03/string-to-integer-atoi/","link":"","permalink":"http://faramita.us/2017/03/03/string-to-integer-atoi/","excerpt":"","text":"DescriptionDifficulty: Medium Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Note: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. CheatSheetRequirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Solution123456789101112131415161718192021222324252627282930313233class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" str = str.strip() if str == '': return 0 neg = False nums = '0123456789' if str[0] == '-': neg = True str = str[1:] elif str[0] == '+': neg = False str = str[1:] if str == '' or str[0] not in nums: return 0 for i in xrange(len(str)): if str[i] not in nums: str = str[:i] break if str == '': return 0 if neg == False: return min(int(str), 2147483647) else: return max(-int(str), -2147483648)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"283. Move Zeroes","slug":"move-zeroes","date":"2017-02-28T14:07:00.000Z","updated":"2017-02-28T14:15:24.000Z","comments":true,"path":"2017/02/28/move-zeroes/","link":"","permalink":"http://faramita.us/2017/02/28/move-zeroes/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array nums, write a function to move all 0â€™s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. å°†æ•°åˆ—ä¸­çš„æ‰€æœ‰ 0 ç§»åˆ°æœ«å°¾ï¼Œå…¶ä»–å…ƒç´ ä¿æŒä¸å˜ã€‚è¦æ±‚åŸåœ°æ‰§è¡Œ Solutionè®¾å®šå·¥ä½œæŒ‡é’ˆåˆå§‹ä¸º 0 ä½ç½®ï¼Œè®¾å®š tail æŒ‡é’ˆæŒ‡å‘é 0 å°¾éƒ¨ã€‚è‹¥å·¥ä½œæŒ‡é’ˆæŒ‡å‘å…ƒç´ ä¸º 0ï¼Œåˆ™å°†è¯¥å…ƒç´ ç§»åŠ¨åˆ° tail ä½ç½®ï¼Œtail å‰ç§»ä¸€ä½ï¼›è‹¥å·¥ä½œæŒ‡é’ˆæŒ‡å‘å…ƒç´ é 0ï¼Œå·¥ä½œæŒ‡é’ˆåç§»ä¸€ä½ï¼Œç›´è‡³å·¥ä½œæŒ‡é’ˆé‡åˆ° tailã€‚å®ç°å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" # nums = moveZeroes_main(nums) length = len(nums) tail = length - 1 if length &gt; 1: for i in xrange(length-1, 0, -1): if nums[i] == 0: # if there are zeros at the end tail -= 1 else: break j = 0 while j &lt; tail: if nums[j] == 0: for k in xrange(j, tail): nums[k] = nums[k+1] nums[tail] = 0 tail -= 1 else: j += 1 æœ€åˆè€ƒè™‘å†™ä¸€ä¸ªé€’å½’çš„æ–¹æ³•å®ç°ï¼Œæ¯æ¬¡è®²æœ«å°¾ 0 å’Œå¼€å¤´ç¡®å®šé 0 éƒ¨åˆ†ç•¥å»ã€‚ä½†æ˜¯ Python çš„ list æ¯æ¬¡åˆ‡åˆ†æ—¶éƒ½ä¼šå¤åˆ¶ï¼Œå› æ­¤ä¸æ»¡è¶³åŸåœ°æ‰§è¡Œä»¥åŠä¸ä½¿ç”¨ return çš„è¦æ±‚ã€‚ä½†æ˜¯è¿™ä¸ªæ–¹æ³•æˆ‘å¾ˆå–œæ¬¢ï¼Œæ— è®ºå¦‚ä½•è¿˜æ˜¯é™„ä¸Š 123456789101112131415def moveZeroes_main(nums): tail = len(nums) if tail &gt; 1: if nums[-1] == 0: # tail = len(''.join([str(i) for i in nums]).rstrip('0')) return moveZeroes_main(nums[:-1]) + [0] else: if nums[0] == 0: for j in xrange(1, tail): nums[j-1] = nums[j] nums[-1] = 0 return moveZeroes_main(nums) else: return [nums[0]] + moveZeroes_main(nums[1:tail]) return nums","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"463. Island Perimeter","slug":"island-perimeter","date":"2017-02-26T17:35:00.000Z","updated":"2017-02-27T16:00:00.000Z","comments":true,"path":"2017/02/27/island-perimeter/","link":"","permalink":"http://faramita.us/2017/02/27/island-perimeter/","excerpt":"","text":"DescriptionDifficulty: Easy You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesnâ€™t have â€œlakesâ€ (water inside that isnâ€™t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height donâ€™t exceed 100. Determine the perimeter of the island. Example:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: æ‰¾ 1 ç»„æˆçš„ã€Œå²›ã€çš„è¾¹ç•Œã€‚ Solution1 ä¸ 0 äº¤æ›¿æ—¶ã€ä»¥åŠ 1 å…ƒç´ è¶Šç•Œæ—¶ä¸ºè¾¹ç•Œã€‚å®šä¹‰äº†ä¸€ä¸ªæ–¹æ³•ï¼Œæ¢æµ‹è¯¥ä½ç½®æ˜¯å¦ä¸º 0ï¼Œæˆ–åæ ‡åŒ…å«è´Ÿæ•°ï¼Œæˆ–æ•°ç»„è¶Šç•Œã€‚å¯¹ 1 å‘¨å›´å…ƒç´ ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ï¼Œè¿™äº›æƒ…å†µè¾¹ç•Œé•¿åº¦åŠ ä¸€ã€‚ 12345678910111213141516171819202122232425262728def testSurround(grid, perimeter, x, y): if x &lt; 0 or y &lt; 0: perimeter += 1 else: try: z = grid[x][y] except IndexError: perimeter += 1 else: if z == 0: perimeter += 1 return perimeterclass Solution(object): def islandPerimeter(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" perimeter = 0 for i in xrange(len(grid)): for j in xrange(len(grid[i])): if grid[i][j] == 1: perimeter = testSurround(grid, perimeter, i, j - 1) perimeter = testSurround(grid, perimeter, i, j + 1) perimeter = testSurround(grid, perimeter, i - 1, j) perimeter = testSurround(grid, perimeter, i + 1, j) return perimeter","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"500. Keyboard Row","slug":"keyboard-row","date":"2017-02-26T17:07:00.000Z","updated":"2017-02-26T17:10:51.000Z","comments":true,"path":"2017/02/27/keyboard-row/","link":"","permalink":"http://faramita.us/2017/02/27/keyboard-row/","excerpt":"","text":"DescriptionDifficulty: Easy Given a List of words, return the words that can be typed using letters of alphabet on only one rowâ€™s of American keyboard. Example 1:Input: [â€œHelloâ€, â€œAlaskaâ€, â€œDadâ€, â€œPeaceâ€]Output: [â€œAlaskaâ€, â€œDadâ€] Note:You may use one character in the keyboard more than once.You may assume the input string will only contain letters of alphabet. ç»™ä¸€ç»„è¯ï¼ˆå­—æ¯ç»„æˆï¼‰ï¼Œè¿”å›ä¸€å­é›†ï¼Œå…¶ä¸­å•è¯å¯ä»…ç”¨é”®ç›˜ä¸ŠæŸä¸€è¡Œæ‰“å‡ºã€‚ Solutionå…ˆåˆ›å»ºä¸‰ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ†åˆ«åŒ…å«é”®ç›˜ä¸Šä¸‰è¡Œçš„å­—æ¯ï¼ˆå¤§å°å†™ï¼‰ï¼Œç„¶åéå†æ¯ä¸ªå•è¯åç»­å­—æ¯æ˜¯å¦ä¸ç¬¬ä¸€ä¸ªå­—æ¯åœ¨åŒä¸€è¡Œï¼›æ³¨æ„å‘ç°ä¸åŒæ—¶è·³è¿‡å½“å‰å•è¯èŠ‚çœæ—¶é—´ã€‚ 12345678910111213141516171819202122232425262728293031class Solution(object): def findWords(self, words): \"\"\" :type words: List[str] :rtype: List[str] \"\"\" row1 = 'qwertyuiopQWERTYUIOP' row2 = 'asdfghjklASDFGHJKL' row3 = 'zxcvbnmZXCVBNM' rslt = [] if words == []: return [] for i in words: lead = [] if i[0] in row1: lead = row1 elif i[0] in row2: lead = row2 elif i[0] in row3: lead = row3 diff = 0 for j in i: if j not in lead: diff = 1 break if diff == 0: rslt.append(i) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"461. Hamming Distance","slug":"hamming-distance","date":"2017-02-26T02:39:00.000Z","updated":"2017-02-26T02:43:05.000Z","comments":true,"path":"2017/02/26/hamming-distance/","link":"","permalink":"http://faramita.us/2017/02/26/hamming-distance/","excerpt":"","text":"DescriptionDifficulty: Easy The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 â‰¤ x, y &lt; 231. Example:Input: x = 1, y = 4 Output: 2 Explanation:1 (0 0 0 1)4 (0 1 0 0) â†‘ â†‘ The above arrows point to positions where the corresponding bits are different. Solutionå…ˆè½¬æ¢ä¸ºäºŒè¿›åˆ¶ï¼Œå°†çŸ­çš„ä¸€æ–¹è¡¥è¶³ä½æ•°ï¼ˆ0ï¼‰ï¼Œç„¶åä¸¤ä¸ªæ•°å­—ç›¸åŠ ã€‚è‹¥å…ƒç´ ç›¸åŒï¼Œç»“æœ æ˜¯ 0 æˆ–è€… 2ï¼Œå› æ­¤è¿”å›åˆå¹¶æ•°ç»„ä¸­ 1 çš„æ•°é‡ã€‚ 123456789101112131415161718192021222324from operator import addclass Solution(object): def hammingDistance(self, x, y): \"\"\" :type x: int :type y: int :rtype: int \"\"\" if x == y: return 0 x_s = [int(i) for i in bin(x)[2:]] y_s = [int(i) for i in bin(y)[2:]] if len(y_s) &lt; len(x_s): x_s, y_s = y_s, x_s if len(x_s) &lt; len(y_s): x_s = [0] * (len(y_s) - len(x_s)) + x_s comb = map(add, x_s, y_s) return comb.count(1)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"104. Maximum Depth of Binary Tree","slug":"maximum-depth-of-binary-tree","date":"2017-02-24T16:41:17.000Z","updated":"2017-02-24T16:43:37.000Z","comments":true,"path":"2017/02/25/maximum-depth-of-binary-tree/","link":"","permalink":"http://faramita.us/2017/02/25/maximum-depth-of-binary-tree/","excerpt":"","text":"DescriptionDifficulty: Easy Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Solutionå…¶å®åªæ˜¯æ·±åº¦éå†ï¼ŒåŒæ—¶è®°å½•æ·±åº¦ã€‚æ­¤å¤„ä½¿ç”¨æœ€ç®€å•çš„ä¸­åºéå†ï¼Œstack åœ¨æŠ¼å…¥èŠ‚ç‚¹çš„åŒæ—¶å‹å…¥è¯¥èŠ‚ç‚¹é«˜åº¦ï¼Œä»¥ä¾¿å–å‡ºèŠ‚ç‚¹åŒæ—¶æ¢å¤é«˜åº¦ã€‚ 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if root == None: return 0 myStack = [] node = root # working pointer treeDepth = 0 maxDepth = 0 while node != None or myStack != []: while node != None: # if still have left child treeDepth += 1 myStack.append((node, treeDepth)) node = node.left # run out of lefts now = myStack.pop() node = now[0] maxDepth = max(maxDepth, treeDepth) treeDepth = now[1] node = node.right return maxDepth","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"2. Add Two Numbers","slug":"add-two-numbers","date":"2017-02-24T16:01:00.000Z","updated":"2017-02-25T09:48:50.000Z","comments":true,"path":"2017/02/25/add-two-numbers/","link":"","permalink":"http://faramita.us/2017/02/25/add-two-numbers/","excerpt":"","text":"DescriptionDifficulty: Easy You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solutionå®ç°ä¸€ä¸ªä½ä½åˆ°é«˜ä½çš„åŠ æ³•è¿ç®—ã€‚æ³¨æ„è¿›ä½å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" l_r = ListNode(0) head = l_r plus1 = 0 while l1 != None or l2 != None: if plus1 == 0: l_n = ListNode(0) l_r.next = l_n l_r = l_n if l1 == None: l_r.val = l2.val + plus1 elif l2 == None: l_r.val = l1.val + plus1 else: l_r.val = l1.val + l2.val + plus1 plus1 = 0 if l_r.val &gt;= 10: plus1 = 1 l_r.val = l_r.val - 10 if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if plus1 == 1: l_n = ListNode(1) l_r.next = l_n l_r = l_n return head.next","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"3. Longest Substring Without Repeating Characters","slug":"longest-substring-without-repeating-characters","date":"2017-02-23T04:19:24.000Z","updated":"2017-02-24T16:49:35.000Z","comments":true,"path":"2017/02/23/longest-substring-without-repeating-characters/","link":"","permalink":"http://faramita.us/2017/02/23/longest-substring-without-repeating-characters/","excerpt":"","text":"DescriptionDifficulty: Medium Given a string, find the length of the longest substring without repeating characters. Example1:Given â€œabcabcbbâ€, the answer is â€œabcâ€, which the length is 3. Given â€œbbbbbâ€, the answer is â€œbâ€, with the length of 1. Given â€œpwwkewâ€, the answer is â€œwkeâ€, with the length of 3. Note that the answer must be a substring, â€œpwkeâ€ is a subsequence and not a substring. Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solutioné‡ç‚¹æ˜¯å­—ç¬¦ä¸²è¶…é•¿æ—¶çš„æ‰§è¡Œæ•ˆç‡ã€‚ æˆ‘ä½¿ç”¨çš„æ–¹æ³•ï¼šä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘ substring æœ€å³ç«¯ï¼Œä½œä¸ºå·¥ä½œæŒ‡é’ˆä¸åœå‘å³ï¼›å¦ä¸€ä¸ªæŒ‡é’ˆåˆå§‹æŒ‡å‘å­—ç¬¦ä¸²å¼€å¤´ï¼›é‡åˆ°é‡å¤æ—¶æŒ‡å‘å­—ç¬¦ä¸²å¼€å¤´çš„æŒ‡é’ˆå‘å³ç§»åŠ¨ä¸€ä¸ªï¼Œå³ substring å»æ‰å¤´éƒ¨ä¸€ä¸ªå­—ç¬¦ï¼Œå†æ£€æµ‹æŒ‡å‘ substring æœ€å³ç«¯çš„æŒ‡é’ˆæŒ‡å‘çš„å­—æ¯æ˜¯å¦é‡å¤ã€‚ è¿™æ ·å®ç°ä»…éœ€è¦éå†ä¸€éæ•´ä¸ªå­—ç¬¦ä¸²ã€‚ 12345678910111213141516171819202122class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) &lt;= 1: return len(s) sub = '' max_l = 0 i = 0 while i &lt; len(s): if s[i] not in sub: sub += s[i] max_l = max(max_l, len(sub)) i += 1 else: sub = sub[1:] return max_l","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"7. Reverse Integer","slug":"reverse-integer","date":"2017-02-22T16:05:30.000Z","updated":"2017-02-23T04:18:52.000Z","comments":true,"path":"2017/02/23/reverse-integer/","link":"","permalink":"http://faramita.us/2017/02/23/reverse-integer/","excerpt":"","text":"DescriptionDifficulty: Easy Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution123456789101112131415class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" x_s = str(x)[::-1] if x &lt; 0: x_s = '-' + x_s[:-1] if int(x_s) &gt; 2147483647 or int(x_s) &lt; -2147483648: return 0 else: return int(x_s)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"1. Two Sum","slug":"two-sum","date":"2017-02-22T10:43:48.000Z","updated":"2017-02-23T04:12:35.000Z","comments":true,"path":"2017/02/22/two-sum/","link":"","permalink":"http://faramita.us/2017/02/22/two-sum/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution1234567891011class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"Hello World!","slug":"hello-world","date":"2017-02-22T02:17:42.000Z","updated":"2017-02-23T04:12:52.000Z","comments":true,"path":"2017/02/22/hello-world/","link":"","permalink":"http://faramita.us/2017/02/22/hello-world/","excerpt":"","text":"ç»ˆäºæœ‰äº†ä¸€ä¸ªè¶³å¤Ÿå¼ºå¤§çš„åŠ¨æœºè®©æˆ‘çœŸæ­£å¼€å§‹å†™åšå®¢ã€‚æœ¬åšå®¢çš„ä¸»è¦å†…å®¹å°†æ˜¯ç®—æ³•åŠå…¶ä»–ç¼–ç çš„ç¬”è®°ï¼Œä»¥åŠä¸€äº›æ€è€ƒã€‚","categories":[],"tags":[{"name":"thinking","slug":"thinking","permalink":"http://faramita.us/tags/thinking/"}]}]}