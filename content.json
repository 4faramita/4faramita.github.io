{"meta":{"title":"之言片语","subtitle":null,"description":"Buried alive.","author":"4faramita","url":"http://faramita.us"},"pages":[{"title":"tags","date":"2017-05-01T15:48:32.000Z","updated":"2017-05-01T15:48:32.000Z","comments":true,"path":"tags/index.html","permalink":"http://faramita.us/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"1000. 函数求值","slug":"super-addition","date":"2017-06-22T09:06:30.000Z","updated":"2017-06-22T09:07:40.000Z","comments":true,"path":"2017/06/22/super-addition/","link":"","permalink":"http://faramita.us/2017/06/22/super-addition/","excerpt":"","text":"DescriptionDifficulty: Easy定义超级和函数F如下： F(0, n) = n，对于所有的正整数n..F(k, n) = F(k – 1, 1) + F(k – 1, 2) + … + F(k – 1, n)，对于所有的正整数k和n. 请实现下面Solution类中计算F(k, n)的函数（1 &lt;= k, n &lt;= 14）. class Solution {public: int F(int k, int n) { } }; 例1：F(1, 3) = 6 例2：F(2, 3) = 10 例3：F(10, 10) = 167960 Solution递归求解，翻译成代码即可。 12345678910111213141516class Solution &#123; public: int F(int k, int n) &#123; if (k == 0) &#123; return n; &#125; else if (k &gt; 0) &#123; int subsum = 0; for (int i = 1; i &lt;= n; i++) &#123; subsum += F(k - 1, i); &#125; return subsum; &#125; else &#123; return -1; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"1002. 等价二叉树","slug":"trees-are-equal","date":"2017-06-22T09:04:48.000Z","updated":"2017-06-22T09:05:53.000Z","comments":true,"path":"2017/06/22/trees-are-equal/","link":"","permalink":"http://faramita.us/2017/06/22/trees-are-equal/","excerpt":"","text":"DescriptionDifficulty: Easy两个二叉树结构相同，且对应结点的值相同，我们称这两个二叉树等价. 例如：以下两个二叉树等价 1 1 / \\ / \\ 2 3 2 3而以下两个则不等价 1 1 / \\ / \\ 2 3 3 2以下两个也不等价 1 1 / \\ / \\ 2 3 2 2 给出两个二叉树p和q，判断它们是否等价. p和q的结点数不多于100000，每个结点的数值在1和1000000000之间. 请为下面的Solution类实现解决上述问题的isEqual函数，函数的两个参数p和q分别代表两个二叉树的根节点，如果以p和q为根的二叉树等价则函数返回true，否则返回false. /* Definition for a binary tree node. struct TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; /class Solution {public: bool isEqual(TreeNode p, TreeNode q) { } }; Solution递归地比较两棵树的根结点、左右节点。 1234567891011121314class Solution &#123; public: bool isEqual(TreeNode* p, TreeNode* q) &#123; bool result = false; if (p == NULL &amp;&amp; q == NULL) &#123; result = true; &#125; else if (p != NULL &amp;&amp; q != NULL)&#123; if (p-&gt;val == q-&gt;val) &#123; result = true &amp;&amp; isEqual(p-&gt;left, q-&gt;left) &amp;&amp; isEqual(p-&gt;right, q-&gt;right); &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"1001. 会议安排","slug":"assign-conference-room","date":"2017-06-22T09:02:03.000Z","updated":"2017-06-22T09:04:07.000Z","comments":true,"path":"2017/06/22/assign-conference-room/","link":"","permalink":"http://faramita.us/2017/06/22/assign-conference-room/","excerpt":"","text":"DescriptionDifficulty: EasyN个会议要同时举行，参会人数分别为A[0], A[1], …, A[N-1]. 现有M个会议室，会议室可容纳人数分别为B[0], B[1], …, B[M-1]. 当A[i]&lt;=B[j]时，可以把会议i安排在会议室j，每间会议室最多安排一个会议，每个会议最多只能安排一个会议室. 求最多安排多少个会议. 1 &lt;= N, M &lt;= 100000, 每个会议的参会人数和每间会议室的容纳人数均在1和1000之间. 请为下面的Solution类实现解决上述问题的函数assignConferenceRoom. 函数参数A和B的意义如上，返回值为最多可安排的会议数. class Solution {public: int assignConferenceRoom(vector&amp; A, vector&amp; B) { } }; 例1：A={2, 3}, B={1, 2}，答案为1. 例2：A={3, 4, 5}，B={10, 3, 2}，答案为2. Solution两个数组排序；先丢弃超过最大会议室容量的会议，然后最大的屋子匹配人数最多的会议。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int assignConferenceRoom(std::vector&lt;int&gt; &amp;A, std::vector&lt;int&gt; &amp;B) &#123; using namespace std; int arrangements = 0; sort(A.begin(), A.end()); sort(B.begin(), B.end()); reverse(A.begin(), A.end()); reverse(B.begin(), B.end()); vector&lt;int&gt;::iterator p = A.begin(); vector&lt;int&gt;::iterator q = B.begin(); while (*p &gt; *q) &#123; p++; &#125; while (p != A.end() &amp;&amp; q != B.end()) &#123; if (*p &lt;= *q) &#123; arrangements += 1; p++; q++; &#125; else &#123; p++; &#125; &#125; return arrangements; &#125;&#125;;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"1005. 最大和","slug":"maxsum","date":"2017-06-22T08:56:24.000Z","updated":"2017-06-22T09:00:58.000Z","comments":true,"path":"2017/06/22/maxsum/","link":"","permalink":"http://faramita.us/2017/06/22/maxsum/","excerpt":"","text":"Description从数列A[0], A[1], A[2], …, A[N-1]中选若干个数，要求相邻的数不能都选，也就是说如果选了A[i], 就不能选A[i-1]和A[i+1]. 求能选出的最大和. 1 &lt;= N &lt;= 100000, 1 &lt;= A[i] &lt;= 1000 请为下面的Solution类实现解决上述问题的函数maxSum，函数参数A是给出的数列，返回值为所求的最大和. class Solution {public: int maxSum(vector&amp; A) { } }; 例1：A = {2, 5, 2}，答案为5. 例2：A = {2, 5, 4}，答案为6. Solution动态规划：每个点只有两种可能，选或不选。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;private: map&lt;int, int&gt; save; int size; bool changed;public: Solution() &#123; changed = false; &#125;public: int doRealJob(vector&lt;int&gt;::iterator begin, vector&lt;int&gt;::iterator end, int currSize) &#123; using namespace std; int result = 0; int position = 0; if (!changed) &#123; size = currSize; changed = true; &#125; else &#123; position = size - currSize; &#125; map&lt;int, int&gt;::iterator mit; mit = save.find(position); if (mit != save.end()) &#123; result = mit-&gt;second; &#125; else &#123; vector&lt;int&gt;::iterator tmp = begin; if (begin != end) &#123; if (++tmp == end) &#123; // only 1 element remaining result = *begin; &#125; else &#123; int first = *begin; begin++; tmp = begin; if (++tmp == end) &#123; // 2 elements remaining result = first &gt; *begin ? first : *begin; &#125; else &#123; // at least 3 elements remaining int orNot = doRealJob(begin, end, currSize - 1); begin++; int now = first + doRealJob(begin, end, currSize - 2); result = now &gt; orNot ? now : orNot; &#125; &#125; save[position] = result; &#125; &#125; return result; &#125;public: int maxSum(vector&lt;int&gt; &amp;A) &#123; vector&lt;int&gt;::iterator begin = A.begin(); vector&lt;int&gt;::iterator end = A.end(); int originSize = A.size(); return doRealJob(begin, end, originSize); &#125;&#125;;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"1004. 无环图","slug":"dag","date":"2017-06-22T08:50:42.000Z","updated":"2017-06-22T09:01:05.000Z","comments":true,"path":"2017/06/22/dag/","link":"","permalink":"http://faramita.us/2017/06/22/dag/","excerpt":"","text":"Description在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个有向无环图（Directed Acyclic Graph，DAG）. 对于一个n个节点的有向图（节点编号从0到n-1），请判断其是否为有向无环图. 图的节点数和边数均不多于100000. 请为下面的Solution类实现解决上述问题的isDAG函数，函数参数中n为图的节点数，edges是边集，edges[i]表示第i条边从edges[i].first指向edge[i].second. 如果是有向无环图返回true，否则返回false. class Solution {public: bool isDAG(int n, vector","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"Coupons","slug":"coupons","date":"2017-06-13T07:17:30.000Z","updated":"2017-06-22T09:13:10.000Z","comments":true,"path":"2017/06/13/coupons/","link":"","permalink":"http://faramita.us/2017/06/13/coupons/","excerpt":"","text":"Description美团点评上有很多餐馆优惠券，用户可以在美团点评App上购买。每张优惠券有一个唯一的正整数编号。当用户在相应餐馆就餐时，可以在餐馆使用优惠券进行消费。优惠券的购买和使用按照时间顺序逐行记录在日志文件中，运营人员会定期抽查日志文件看业务是否正确。业务正确的定义为：一个优惠券必须先被购买，然后才能被使用。 某次抽查时，发现有硬盘故障，历史日志中有部分行损坏，这些行的存在是已知的，但是行的内容读不出来。假设损坏的行可以是任意的优惠券的购买或者使用。 现在问这次抽查中业务是否正确。若有错，输出最早出现错误的那一行，即求出最大s，使得记录1到s-1满足要求；若没有错误，输出-1。 输入描述:m 分别表示 m (1 ≤ m ≤ 5 * 10^5) 条记录。 下面有m行，格式为： I x （I为Input的缩写，表示购买优惠券x）； O x（O为Output的缩写，表示使用优惠券x）； ? （表示这条记录不知道）。 这里x为正整数，且x ≤ 10^5 。 输出描述:-1 或 x(1 ≤ x ≤ m) 其中x为使得1到x-1这些记录合法的最大行号。 输入例子:01O 12？O 13I 1？O 12I 2O 1 输出例子:-11-1-12 Solution使用字典 log_dic 储存已经遍历的条目。主函数 check() 用来检查当前条目是否合法：如果是输入，检测字典中是否已有相同未输出的输入，有则报错；如果是输出，检测字典中是否有相应未输出的输入，没有则报错；每个 “?” 可以抵消一个错误。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# coding = utf-8import sysdef check(log): err_line = -1 log_dic = &#123;&#125; whatever = 0 for i, elem in enumerate(log): if elem[0] == 'I': try: status = log_dic[elem[1]] except KeyError: log_dic[elem[1]] = False # Inport not exist, GOOD else: if status is True: # Import exists, but already outputed, GOOD log_dic[elem[1]] = False else: # Import exists, haven't been outputed, BAD if whatever &gt; 0: # maybe because of hd error, GOOD whatever -= 1 else: err_line = i + 1 break elif elem[0] == 'O': try: status = log_dic[elem[1]] except KeyError: if whatever &gt; 0: whatever -= 1 else: err_line = i + 1 break else: if status is False: log_dic[elem[1]] = True else: if whatever &gt; 0: whatever -= 1 else: err_line = i + 1 break elif elem[0] == '?': whatever += 1 return err_lineif __name__ == '__main__': while True: length = int(sys.stdin.readline().strip()) # if not length: # break log = [] for i in xrange(length): line = sys.stdin.readline().strip().split(' ') log.append(line) print(check(log))","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"Music Study","slug":"music-study","date":"2017-06-13T07:07:45.000Z","updated":"2017-06-13T07:18:27.000Z","comments":true,"path":"2017/06/13/music-study/","link":"","permalink":"http://faramita.us/2017/06/13/music-study/","excerpt":"","text":"Description有两段音频，每段音频是一个表示音高的序列。现在想要在第二段音频中找出与第一段音频最相近的部分。 具体地说，就是在第二段音频中找到一个长度和第一段音频相等且是连续的子序列，使得它们的 difference 最小。两段等长音频的 difference 定义为：difference = SUM(a[i] - b[i])2 (1 ≤ i ≤ n),其中 SUM() 表示求和其中 n 表示序列长度，a[i], b[i] 分别表示两段音频的音高。现在袋鼠先生想要知道，difference 的最小值是多少？数据保证第一段音频的长度小于等于第二段音频的长度。 输入描述:第一行一个整数 n (1 ≤ n ≤ 1000)，表示第一段音频的长度。第二行 n 个整数表示第一段音频的音高（0 ≤ 音高 ≤ 1000）。第三行一个整数 m (1 ≤ n ≤ m ≤ 1000)，表示第二段音频的长度。第四行 m 个整数表示第二段音频的音高（0 ≤ 音高 ≤ 1000）。 输出描述:输出 difference 的最小值 输入例子:21 243 1 2 4 输出例子:0 Solution题目思路很直接，calculate_diff() 计算两个等长数组的 “difference”，针对每一对等长数组，计算这个值即可。 1234567891011121314151617181920212223# coding = utf-8import sysdef calculate_diff(lst1, lst2, length1): sum_diff = 0 for i in xrange(length1): sum_diff += ((lst1[i] - lst2[i]) ** 2) return sum_diffif __name__ == '__main__': length1 = int(sys.stdin.readline().strip()) audio1 = map(int, sys.stdin.readline().strip().split()) length2 = int(sys.stdin.readline().strip()) audio2 = map(int, sys.stdin.readline().strip().split()) min_diff = float('inf'); for i in xrange(length2 - length1 + 1): min_diff = min(min_diff, calculate_diff(audio1, audio2[i:i + length1], length1)) print(min_diff)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"15. 3Sum","slug":"3sum","date":"2017-06-05T16:26:02.000Z","updated":"2017-06-13T07:35:31.000Z","comments":true,"path":"2017/06/06/3sum/","link":"","permalink":"http://faramita.us/2017/06/06/3sum/","excerpt":"","text":"DescriptionDifficulty: Medium Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 题意:给出一数组，返回数组中和为 0 的三个元素的组合。要求去重。 Solution一道经典的题。先考虑 2 sum，针对有序数列，头尾双指针，若当前和大于要求，尾指针前移；若小于要求，头指针后移。时间复杂度 O(n)那么 3 sum 只要针对每个元素算 2 sum 即可，时间复杂度 O(n ^ 2)。问题在于去重。首先的想法是用集合，然而集合无法储存数组，因此先将结果数组排序并转换为元组。然而即使用集合，也是要尝试插入很多次的；另外集合在实现上终究是要查找的，去重不可能没有代价。因此更好得做法是在指针处过滤，若指针当前值与上一个值相等，则跳过当前值。还有一个点：一开始为了防止越界，我在去重代码部分外面加上了 try，然而无法满足时间要求；去掉 try 语句就可以了。try 的开销比我想象的大。 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() result = set() length = len(nums) if length &lt; 3: return [] elif length == 3: if sum(nums) == 0: return[sorted(nums)] for i in xrange(len(nums) - 2): rest = -nums[i] head = i + 1 tail = length - 1 while tail &gt; head: left = nums[head] right = nums[tail] cur_sum = left + right if cur_sum == rest: result.add(tuple(sorted([-rest, left, right]))) head += 1 tail -= 1 while head &lt; tail and nums[head - 1] == nums[head]: head += 1 while head &lt; tail and nums[tail + 1] == nums[tail]: tail -= 1 elif cur_sum &gt; rest: tail -= 1 else: head += 1 return list(result)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"11. Container With Most Water","slug":"container-with-most-water","date":"2017-05-30T15:16:59.000Z","updated":"2017-06-13T07:35:43.000Z","comments":true,"path":"2017/05/30/container-with-most-water/","link":"","permalink":"http://faramita.us/2017/05/30/container-with-most-water/","excerpt":"","text":"DescriptionDifficulty: Medium Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2. 题意:给出一堆整数坐标点，每个点的高度相当于对应挡板的高度；选出两个挡板，与 x 轴组成水桶，求最大容量。 Solution容量由短板和宽度（两个点在 x 上的投影距离）决定。设两个指针，一头一尾。vol 函数计算给出两个指针形成的容积。max_vol 储存最大容积。每算完一次，较短的板子向对方移动一次。 1234567891011121314151617181920212223def vol(height, x, y): return (height[x] if height[x] &lt; height[y] else height[y]) * (y - x)class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" max_vol = 0 length = len(height) head, tail = 0, length - 1 while tail &gt; head: cur_vol = vol(height, head, tail) max_vol = cur_vol if cur_vol &gt; max_vol else max_vol if height[head] &lt; height[tail]: head += 1 else: tail -= 1 return max_vol","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"17. Letter Combinations of a Phone Number","slug":"letter-combinations-of-a-phone-number","date":"2017-05-22T16:49:26.000Z","updated":"2017-06-13T07:35:52.000Z","comments":true,"path":"2017/05/23/letter-combinations-of-a-phone-number/","link":"","permalink":"http://faramita.us/2017/05/23/letter-combinations-of-a-phone-number/","excerpt":"","text":"DescriptionDifficulty: Medium Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Input:Digit string \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note:Although the above answer is in lexicographical order, your answer could be in any order you want. 题意:给出一串数字，求这串数字在 T9 键盘上 能打出的所有字母组合。 Solution算法很简单，预设一个字典，查每个数的对应字母，然后求组合即可。重点在于 Python 有一个强大的工具集：itertoolsitertools 里面的 combination 等方法之前也用过很多次，这次用到的是 product。这个方法能产生输入数组（每组一个元素）所能组成的所有组合，方法文档中的说法是“Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B).”。知道了这个方法这道题也就解开了。 1234567891011121314151617181920212223242526272829import itertoolsclass Solution(object): def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\" num_pad = &#123; '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' &#125; if digits == '': return [] chars = [] for n in digits: chars.append([i for i in num_pad[n]]) char_list = list(itertools.product(*chars)) result = [] for s in char_list: result.append(''.join(list(s))) return result","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"5. Longest Palindromic Substring","slug":"longest-palindromic-substring","date":"2017-05-16T09:09:34.000Z","updated":"2017-06-13T07:35:59.000Z","comments":true,"path":"2017/05/16/longest-palindromic-substring/","link":"","permalink":"http://faramita.us/2017/05/16/longest-palindromic-substring/","excerpt":"","text":"DescriptionDifficulty: Medium Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:Input: “babad” Output: “bab” Note: “aba” is also a valid answer. Example:Input: “cbbd” Output: “bb” 题意:找到给定字符串中最长的（连续）回文子字符串 Solution首先想到的方法是设置一个 len(s) 到 1 的窗口，在字符串上滑动，因为是倒序，所以一旦找到就是最长，可以直接返回。12345678910111213141516171819202122232425class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" length = len(s) if length &lt;= 1: return s max_range = (0, 0) found = False for win in xrange(length, 0, -1): for head in xrange(0, length - win + 1): cur_str = s[head:head + win] if win % 2 == 0: # even l_half, r_half = cur_str[:win / 2], cur_str[win / 2:] elif win % 2 == 1: # odd l_half, r_half = cur_str[:win // 2], cur_str[win // 2 + 1:] if l_half == r_half[::-1]: max_range = (head, head + win) found = True break if found: break return s[max_range[0]:max_range[1]] 一点 tip：本来对比窗口内整个字符串与其反向是否相等，未能满足实验复杂度要求；后来选择将字符串切成两半，对比前一半与后一半的反转，时间复杂度要求即可满足。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"19. Remove Nth Node From End of List","slug":"remove-nth-node-from-end-of-list","date":"2017-05-09T12:35:55.000Z","updated":"2017-06-13T07:36:11.000Z","comments":true,"path":"2017/05/09/remove-nth-node-from-end-of-list/","link":"","permalink":"http://faramita.us/2017/05/09/remove-nth-node-from-end-of-list/","excerpt":"","text":"DescriptionDifficulty: Medium Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note:Given n will always be valid.Try to do this in one pass. 题意:删除链表倒数第 n 个节点。要求仅遍历一遍。 Solution最简单的方法：快慢指针。快指针领先慢指针 n - 1，快指针到达末尾时，删除慢指针指向元素。为了删除方便，再定义 slow_p 指向慢指针之前元素。顺便，可以判断一些边际状况：fast, slow 与 slow_p 都初始化为 head，因此： 若 fast == slow == slow_p，则原链表只有一个节点，并且删除这个节点，返回 [] 若 slow == slow_p，则需要删除第一个元素，返回 head.next 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" fast, slow, slow_p = head, head, head n_copy = n - 1 while n_copy &gt; 0: fast = fast.next n_copy -= 1 while fast.next: fast = fast.next slow_p = slow slow = slow.next if fast == slow == slow_p: return [] elif slow == slow_p: return head.next else: slow_p.next = slow.next return head","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"23. Merge k Sorted Lists","slug":"merge-k-sorted-lists","date":"2017-05-02T13:35:48.000Z","updated":"2017-06-13T07:36:23.000Z","comments":true,"path":"2017/05/02/merge-k-sorted-lists/","link":"","permalink":"http://faramita.us/2017/05/02/merge-k-sorted-lists/","excerpt":"","text":"DescriptionDifficulty: Hard Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 题意:合并 k 个有序链表 Solution算法有如下几个要点： 去除空链表 k 个指针指向每个链表当前最小元素 维护一个当前最小值数组，其中只包含每个链表当前最小值或 None 每次抽走最小值，更新最小值数组。 单独使用一个最小值数组的原因，也是本算法一个小想法：主循环的判断条件是：while eval(&#39; or &#39;.join(curr)) is not None:，其中 curr 是最小值数组。用一个 eval() 来判断是否所有链表都遍历完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeKLists(self, lists): \"\"\" :type lists: List[ListNode] :rtype: ListNode \"\"\" # copy lists pts = [] for i in lists: pts.append(i) length = len(lists) copy_index, copy_length = 0, length while copy_length &gt; 0 and copy_index &lt; copy_length: if pts[copy_index] is None: del(pts[copy_index]) copy_length -= 1 else: copy_index += 1 length = len(pts) if length == 0: return None elif length == 1: return pts[0] head = ListNode('head') # working pointer p = head curr = [] for i in pts: if i and (i.val is not None): curr.append(str(i.val)) else: curr.append('None') while eval(' or '.join(curr)) is not None: min_val, min_index = float('inf'), -1 for i in xrange(length): if pts[i] and (pts[i].val is not None) and pts[i].val &lt; min_val: min_val, min_index = pts[i].val, i p.next = pts[min_index] p = p.next if pts[min_index]: pts[min_index] = pts[min_index].next if pts[min_index]: curr[min_index] = str(pts[min_index].val) else: curr[min_index] = 'None' return head.next 这个算法很不幸还没有 AC，最后一个测试用例运行时间无法满足。我会继续更新。但我觉得这个算法很有趣，特此记录。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"JavaScript: this, 这个到底是哪个？","slug":"javascript-what-this-is","date":"2017-05-01T14:25:59.000Z","updated":"2017-05-01T15:55:37.000Z","comments":true,"path":"2017/05/01/javascript-what-this-is/","link":"","permalink":"http://faramita.us/2017/05/01/javascript-what-this-is/","excerpt":"","text":"最近做项目过程中，遇到了一个问题：因为需要解析 JavaScript 代码，所以会需要解析 this 指的是什么。经过一番实验查询，现在有了一个初步的结果，特此记录。 this 一般来说只存在于方法体中，而其指代，说白了就三种情况。 一般情况一般情况下，this 指代调用所在方法的对象。示例： 123456789function testThis () &#123; console.log(this.x)&#125;let obj = &#123;&#125;obj.x = 1obj.testThis = testThisobj.testThis() // 打印 1 当 obj 调用 testThis 时，this 指向调用者 obj。 需要注意的是，这里 this 只与方法调用位置有关，与方法定义位置无关。示例： 12345678910let obj1 = &#123;&#125;obj1.x = 1obj1.testThis = function () &#123; console.log(this.x)&#125;let obj2 = &#123;&#125;obj2.x = 2obj2.testThis = obj1.testThisobj2.testThis() // 打印 2 全局调用特别地，若直接调用这个方法，这个方法的调用者为默认全局对象，如浏览器中的 [Object Window]，或是 node 中的 [object global]。示例如下： 1234567function testThis () &#123; console.log(this.x)&#125;global.x = 2testThis() // 打印 2 类调用在类定义的代码块（包括构造方法）中，this 默认指代这个类本身（或者说在类被实例化之后指这个实例）。示例如下： 12345678910111213class TestThis &#123; constructor () &#123; this.x = 3 &#125; printThis () &#123; console.log(this.x) &#125;&#125;test = new TestThis()console.log(test.x) // 打印 3test.printThis() // 打印 3 特殊情况说完了一般情况，下面是有一点特殊的情况。 apply() 与 call()关于 apply()，我无法比阮一峰老师解释的更清楚了，这里引用他的解释： apply() 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this 指的就是这第一个参数。 而 call() 于 apply() 的区别仅在于参数传入方式，示例： 123456789101112let obj1 = &#123;&#125;let obj2 = &#123;&#125;obj1.x = 1obj2.x = 2obj1.testThis = function (a1, a2) &#123; console.log(this.x)&#125;obj.testThis.apply(obj2, ['a1', 'a2']) // 打印 2obj.testThis.call(obj2, 'a1', 'a2') // 打印 2 a1, a2 为 obj1.testThis 的参数。可以看到 apply() 的将参数以数组（apply() 的第二个参数）方式传入，而 call() 将第一个参数之后的参数直接传入作为参数列表。 forEach()forEach() 方法在 ECMAScript 5.1 首次被引入，语法如下： arr.forEach(callback[, thisArg]) 可以看到第一个参数是回调函数，而第二个参数是可选的，指定 this 的指代。值得注意的是，如果在此处不特别指定 this 的指代，this 将回落为指代全局对象。示例： 12345let a = [1，2]a.forEach(function () &#123; console.log(this.toString()) // 打印 [object global] 两次 &#125;) 特别感谢与更多参考MDN 上 forEach() 方法的文档：Array.prototype.forEach() 阮一峰老师关于 this 的解释：Javascript 的 this 用法 Maplewing 在英特尔开发人员专区关于 this 的解释：#Javascript：this 用法整理","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faramita.us/tags/javascript/"}]},{"title":"A Update Of The Template Tool For My Blog","slug":"a-update-of-the-template-tool-for-my-blog","date":"2017-04-27T04:37:09.000Z","updated":"2017-04-27T05:02:54.000Z","comments":true,"path":"2017/04/27/a-update-of-the-template-tool-for-my-blog/","link":"","permalink":"http://faramita.us/2017/04/27/a-update-of-the-template-tool-for-my-blog/","excerpt":"","text":"博客模板工具再次更新！毕竟这个博客并不只是为了记录题目（虽然这是一个主要用途），那么写作其他内容时需要一个简单的模板，只包含标题，标签和时间。于是有了这次更新。同时，我把这个小脚本放在了 GitHub 上，虽然我几乎确定这个轮子已经被造了无数遍了，但是自己用还是自己写比较方便。 地址：https://github.com/4faramita/Hexo-Template-Generator","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"122. Best Time to Buy and Sell Stock II","slug":"best-time-to-buy-and-sell-stock-ii","date":"2017-04-24T16:38:00.000Z","updated":"2017-06-13T07:38:28.000Z","comments":true,"path":"2017/04/25/best-time-to-buy-and-sell-stock-ii/","link":"","permalink":"http://faramita.us/2017/04/25/best-time-to-buy-and-sell-stock-ii/","excerpt":"","text":"DescriptionDifficulty: Easy Say you have an array for which the i(th) element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 给出一个数列，第 i 个位置代表第 i 天的股价，求最大利润。隐含条件是每次买卖一股，本金不限。 Solution思路：炒股的思路很简单：高买低卖。本题等于有上帝视角，那么只需找出所有单调递增段，最低点买入最高点卖出即可。 定义变量：low：当前单调递增周期中低点；若位于单调递减周前则为 Nonehigh：当前单调递增周期中高点；profit：累计利润up：标记是否位于单调递增区间。 扫描一遍数列：开始时长度小于 3 的基本情况。 数列更大时：维护当前单调递增周期的 low 与 high；当前单调递增周期结束时（后一值小于前一值）结算一次利润，同时 up = False，low = None重新到达单调递增区间时重新设定 low 为低点。 123456789101112131415161718192021222324252627282930class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if len(prices) &lt;= 1: return 0 elif len(prices) == 2: return max(prices[1] - prices[0], 0) low = prices[0] high = prices[0] profit = 0 up = True for i in xrange(len(prices) - 1): if prices[i + 1] &gt;= prices[i]: # going up high = prices[i + 1] up = True if low == None: low = prices[i] elif prices[i + 1] &lt; prices[i]: if up == True: profit += (high - low) up = False low = None if up == True: profit += (high - low) return profit","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"121. Best Time to Buy and Sell Stock","slug":"best-time-to-buy-and-sell-stock","date":"2017-04-18T08:51:32.000Z","updated":"2017-06-13T07:38:37.000Z","comments":true,"path":"2017/04/18/best-time-to-buy-and-sell-stock/","link":"","permalink":"http://faramita.us/2017/04/18/best-time-to-buy-and-sell-stock/","excerpt":"","text":"DescriptionDifficulty: Easy Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. 给出一数组，代表每天的股价。要求只能买卖一次，求最大利润。 Solution实际上是求数组中后面的数与前面的数的最大差值。最简单的方法自然是两个循环，但是时间复杂度为 O(n^2)，很不理想。 思路：由于在每个单调区间中对答案有意义的元素只有区间两端的值而已。因此构建两个新数组，分别只包含每个单调区间的最大值与最小值。之后，针对最小值数组中每个元素，找最大值数组相应位置及之后的最大元素即可算出最大差值（利润） 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" max_profit = 0 if len(prices) == 2: return max(prices[1] - prices[0], 0) elif len(prices) &gt; 2: low = prices[0] high = prices[0] profit = 0 list_low = [prices[0]] list_high = [] up = True for i in xrange(len(prices) - 1): if prices[i + 1] &gt;= prices[i]: # going up high = prices[i + 1] if up == False: low = prices[i] list_low.append(low) up = True elif prices[i + 1] &lt; prices[i]: # going down low = prices[i + 1] if up == True: high = prices[i] list_high.append(high) up = False if len(list_high) &lt; len(list_low): list_high.append(prices[-1]) for j in xrange(len(list_low)): max_profit = max(max_profit, max(list_high[j:]) - list_low[j]) return max_profit","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"一个更新 ShadowsocksX-NG-R8 的小工具","slug":"ShadowsocksX-NG-R8-Updater","date":"2017-04-14T15:48:02.000Z","updated":"2017-04-14T16:03:53.000Z","comments":true,"path":"2017/04/14/ShadowsocksX-NG-R8-Updater/","link":"","permalink":"http://faramita.us/2017/04/14/ShadowsocksX-NG-R8-Updater/","excerpt":"","text":"在国内上网的话，绕不开 GFW 这个话题。要翻墙的话，如果你在用 macOS，那么 ShadowsocksX-NG-R8 是个不错的选择。ShadowsocksX-NG 从 ShadowsocksX fork 而来，而 ShadowsocksX-NG-R8 又是 ShadowsocksX-NG 的支持 ShadowsocksR 的 fork，目前维护十分活跃。 维护活跃就意味着更新频繁，当然这是件好事，但是每次打开网页手工下载实在太麻烦。于是写了个这个小工具用于自动下载最新版本。 ShadowsocksX-NG-R8-Updater 用法克隆仓库： git clone git@github.com:4faramita/ShadowsocksX-NG-R8-Updater.git 脚本用 Node 写成，基于 cheerio 和 request。因此你需要安装 Node 和 npm： brew install node npm 然后安装依赖： npm install cheerio request -g 然后运行即可，文件会下载到脚本所在目录。 cd ShadowsocksX-NG-R8-Updater node updater.js 代理既然你想用这个脚本，我假设你已经在用 ShadowsocksX-NG-R8 并打开了「HTTP 代理」，所以本脚本会自动调用 http://127.0.0.1:1087 作为默认 HTTP 代理。 如果你不想使用代理，请用这个命令 node updater.js -n; 如果你想使用其他代理： node updater.js -y [服务器] [端口]. 比如: node updater.js -y 127.0.0.1 1087. 无需手工添加http://，这也意味着本脚本只支持 HTTP 代理 下一步未来还有一些不痛不痒的功能需要添加，比如 自定义下载路径 校验 GPG Sig 显示下载进度 用 Python 重写","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"70. Climbing Stairs","slug":"climbing-stairs","date":"2017-04-11T02:00:59.000Z","updated":"2017-06-13T07:38:48.000Z","comments":true,"path":"2017/04/11/climbing-stairs/","link":"","permalink":"http://faramita.us/2017/04/11/climbing-stairs/","excerpt":"","text":"DescriptionDifficulty: Easy You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. n 阶楼梯，每次可以爬一阶或者两阶，问有多少种方法。 Solution由于包含动态规划的两个特征： 最优子结构 重复的子问题 因此可用动态规划。 核心算法：为了到达第 i 阶（i &gt;= 3)，可以从 i - 1 阶上一阶，也可以从 i - 2 阶上两阶。递归这个算法即可。 1234567891011class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\" stor = &#123;1: 1, 2: 2&#125; for i in xrange(3, n+1): stor[i] = stor[i-1] + stor[i-2] return stor[n]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"38. Count and Say","slug":"count-and-say","date":"2017-04-04T06:23:48.000Z","updated":"2017-06-13T07:39:09.000Z","comments":true,"path":"2017/04/04/count-and-say/","link":"","permalink":"http://faramita.us/2017/04/04/count-and-say/","excerpt":"","text":"DescriptionDifficulty: Easy The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, … 1 is read off as “one 1” or 11.11 is read off as “two 1s” or 21.21 is read off as “one 2, then one 1” or 1211. Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. 题意:有这样一个数列，下一个元素是由上一个元素按照（元素个数，元素）的方法组成的。求这个数列的第 n 个元素。 Solution迭代：把数列的上一个元素在元素变化的点切分，然后数出每一块的长度即可。_loop 函数用来迭代。 1234567891011121314151617181920212223242526272829303132333435def _loop(s): if len(s) == 1: return '11' head, tail = 1, 0 rslt = [] rslt_s = '' scanning = False while max(head, tail) &lt; len(s): if s[head] == s[tail] and not scanning: scanning = True elif s[head] != s[tail]: rslt.append(s[tail:head]) tail = head if scanning: scanning = False head += 1 # if scanning: rslt.append(s[tail:]) for sub in rslt: rslt_s = rslt_s + str(len(sub)) + sub[0] return rslt_sclass Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" rslt = '1' for i in range(1, n): rslt = _loop(rslt) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"204. Count Primes","slug":"count-primes","date":"2017-03-30T15:07:28.000Z","updated":"2017-06-13T07:33:24.000Z","comments":true,"path":"2017/03/30/count-primes/","link":"","permalink":"http://faramita.us/2017/03/30/count-primes/","excerpt":"","text":"DescriptionDifficulty: Easy (Which I do not agree AT ALL.) Description:Count the number of prime numbers less than a non-negative number, n. 题意:输入一个数，输出小于这个数的所有正整数中有多少个质数。 Solution很多数的素性检测。时间复杂度是关键。最简单的想法是遍历每个数，检查每个数的素性。尽管检查素性的函数效率不低，但是总体效率还是非常低 一番查找之后，我选择了埃拉托斯特尼筛法。这是一个古老而简单的算法，用来找出一定范围内所有素数，流程如下： 初始化两个数列 nums 和 status，nums 储存从 2 开始所有待查的数（因为 1 不是素数），status 储存 nums 中每个数是否为素数，初始化为 True。 从第一个元素 2 开始，将 nums 中每一个该元素（这里为 2） 的倍数标记为合数，方法是将 status 数组对应位置赋值 False。 当最近检查出的素数的平方已经大于 nums 中最大的数时，认为之后所有未标记为合数的数都是质数，算法结束。代码如下12345678910111213141516171819202122232425262728293031class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\" # base cases if n &gt;= 0 and n &lt;= 1: return 0 elif n &lt;= 4: return n - 2 nums = [i for i in range(2, n)] # all the numbers status = [True] * len(nums) # whether a number in nums a prime last_prime = 0 # store the last prime found for elem in enumerate(nums): # elem: (position, value) if (last_prime ** 2) &gt; n - 1: break if status[elem[0]] is False: continue last_prime = elem[1] for p in range(elem[0] + 1, len(nums)): if nums[p] % elem[1] == 0: status[p] = False total = 0 for j in status: if j is True: total += 1 return total 然而，令人难以置信的是，这个算法，在输入值为六位数时，依然超过了时间限制（具体来说执行时间达到了十秒以上）。 于是我不甘心地点开了这道题的 hint 部分。这道题的 hint，锦囊一般，层层嵌套，一个问题引出另一个问题，なんと、有整整八个 hint！前半部分也引导使用每个数的素性检测，之后说只需要检测前 n／2 的数，更进一步发现只需要检测前 n^(1/2) 的数。之后也引出了我之前提到的埃拉托斯特尼筛法，该方法确实是检测大批量数是否为素的好方法。我按照 hint 的引导优化了算法，再次实验。 随着不断修改，最终我将步长改为动态，优化了一系列事件与内存复杂度。最终能在 1s 内执行。因为进行了许多优化，最终答案中也包含许多注释，更多的优化内容在注释中说明。当然，我看答案了，但是最终的算法完全是我根据之前写的 8s 的答案独立修改而来的。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\" # base cases if n &gt;= 0 and n &lt;= 1: return 0 elif n &lt;= 4: return n - 2 # all the nums = [i for i in xrange(n)] # but, as rank and value of nums are the same # as a matter of fact, # they all equal to the natural number of that position # so there\\'s no need to actually create that list # every nums\\' status, True for prime status = [True] * n # 0 and 1 are not primes status[0], status[1] = False, False # without list(nums) # I can still do this step # thanks to the natural number # in the range of [2, sqrt(n - 1)] for elem in xrange(2, int((n - 1) ** 0.5) + 1): # if this num is a prime if status[elem]: # from position num ^ 2 p = elem ** 2 # every step num # set status False while p &lt; n: status[p] = False p += elem # return number of Tures return sum(status) 鉴于 hint 过多，之前写的脚本又没能抓回来，现将网址贴出：204. Count Primes","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"171. Excel Sheet Column Number","slug":"excel-sheet-column-number","date":"2017-03-28T17:04:00.000Z","updated":"2017-06-13T07:33:18.000Z","comments":true,"path":"2017/03/29/excel-sheet-column-number/","link":"","permalink":"http://faramita.us/2017/03/29/excel-sheet-column-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given a column title as appear in an Excel sheet, return its corresponding column number. Example A -&gt; 1 B -&gt; 2 C -&gt; 3 … Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 将 Excel 中使用字母表示的列号转换为数字。 Solution26 进制转换为 10 进制。 1234567891011class Solution(object): def titleToNumber(self, s): \"\"\" :type s: str :rtype: int \"\"\" column = 0 s_r = s[::-1] for i in xrange(len(s_r)): column += ((26 ** i) * (ord(s_r[i]) - 64)) return column","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"172. Factorial Trailing Zeroes","slug":"factorial-trailing-zeroes","date":"2017-03-28T04:47:28.000Z","updated":"2017-06-13T07:33:12.000Z","comments":true,"path":"2017/03/28/factorial-trailing-zeroes/","link":"","permalink":"http://faramita.us/2017/03/28/factorial-trailing-zeroes/","excerpt":"","text":"DescriptionDifficulty: Easy Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 题意:数输入数字的阶乘的末尾由多少个 0。 Solution每个 0 都是由 2 * 5 提供的。但是由于 偶数众多，因此 2 总是足够的；同时有些数字中包含多个 5（如 25），故需要多次重复直到数字中不含 5。 1234567891011class Solution(object): def trailingZeroes(self, n): \"\"\" :type n: int :rtype: int \"\"\" zeros = 0 while n &gt; 0: n /= 5 zeros += n return zeros","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"387. First Unique Character in a String","slug":"first-unique-character-in-a-string","date":"2017-03-26T16:07:00.000Z","updated":"2017-06-13T07:33:05.000Z","comments":true,"path":"2017/03/27/first-unique-character-in-a-string/","link":"","permalink":"http://faramita.us/2017/03/27/first-unique-character-in-a-string/","excerpt":"","text":"DescriptionDifficulty: Easy Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples = “leetcode”return 0. s = “loveleetcode”,return 2. NoteYou may assume the string contain only lowercase letters. 找到一个字符串中不重复的字符，返回其在字符串中位置，如不存在则返回 -1。 Solution思路：维护一个字典，键为字符串中各个字符，值为这样一个数组：[该字符出现次数, 该字符首次出现位置]。扫描一遍字符串，维护字典；扫描一遍字典，维护出现次数为 1 的最小位置，返回这个值。 1234567891011121314151617181920212223242526class Solution(object): def firstUniqChar(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) == 0: return -1 setX = &#123;&#125; for i in xrange(len(s)): try: setX[s[i]][0] += 1 # setX[s[i]][1] = min(setX[s[i]][1], i) except KeyError: setX[s[i]] = [1, i] # (count, first time position) # print(setX) posi = -1 for j in setX: if setX[j][0] == 1: if posi == -1: posi = setX[j][1] elif posi &gt; 0: posi = min(setX[j][1], posi) return posi","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"412. Fizz Buzz","slug":"fizz-buzz","date":"2017-03-26T07:38:00.000Z","updated":"2017-06-13T07:33:00.000Z","comments":true,"path":"2017/03/26/fizz-buzz/","link":"","permalink":"http://faramita.us/2017/03/26/fizz-buzz/","excerpt":"","text":"DescriptionDifficulty: Easy Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Examplen = 15, Return:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] Solution123456789101112131415161718class Solution(object): def fizzBuzz(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" rslt = [] for i in xrange(n): if (i + 1) % 15 == 0: rslt.append('FizzBuzz') elif (i + 1) % 5 == 0: rslt.append('Buzz') elif (i + 1) % 3 == 0: rslt.append('Fizz') else: rslt.append(str(i + 1)) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"461. Hamming Distance","slug":"hamming-distance","date":"2017-03-25T02:39:00.000Z","updated":"2017-06-13T07:32:55.000Z","comments":true,"path":"2017/03/25/hamming-distance/","link":"","permalink":"http://faramita.us/2017/03/25/hamming-distance/","excerpt":"","text":"DescriptionDifficulty: Easy The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 231. Example:Input: x = 1, y = 4 Output: 2 Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. Solution先转换为二进制，将短的一方补足位数（0），然后两个数字相加。若元素相同，结果 是 0 或者 2，因此返回合并数组中 1 的数量。 123456789101112131415161718192021222324from operator import addclass Solution(object): def hammingDistance(self, x, y): \"\"\" :type x: int :type y: int :rtype: int \"\"\" if x == y: return 0 x_s = [int(i) for i in bin(x)[2:]] y_s = [int(i) for i in bin(y)[2:]] if len(y_s) &lt; len(x_s): x_s, y_s = y_s, x_s if len(x_s) &lt; len(y_s): x_s = [0] * (len(y_s) - len(x_s)) + x_s comb = map(add, x_s, y_s) return comb.count(1)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"202. Happy Number","slug":"happy-number","date":"2017-03-24T13:27:07.000Z","updated":"2017-06-13T07:32:47.000Z","comments":true,"path":"2017/03/24/happy-number/","link":"","permalink":"http://faramita.us/2017/03/24/happy-number/","excerpt":"","text":"DescriptionDifficulty: Easy Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 返回输入数字是否是「快乐数」，即重复计算各位数字平方和，如果最终等于 1 则「快乐」。 Solution递归运算，直到算出一位数结果。一位数中只有 1，7 满足条件。为了减少计算量，直接删去数字中的 0。 1234567891011121314151617181920212223242526def happy(n): if n &lt;= 0: return False sum = 0 if n &lt;= 10: if n == 1 or n == 7 or n == 10: return True else: return False # return False elif n &gt; 10: s = str(n).strip('0') for i in s: sum += (int(i) ** 2) return happy(sum)class Solution(object): def isHappy(self, n): \"\"\" :type n: int :rtype: bool \"\"\" return happy(n)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"198. House Robber","slug":"house-robber","date":"2017-03-23T04:30:07.000Z","updated":"2017-06-13T07:32:37.000Z","comments":true,"path":"2017/03/23/house-robber/","link":"","permalink":"http://faramita.us/2017/03/23/house-robber/","excerpt":"","text":"DescriptionDifficulty: Easy You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 一个数组，每个元素是这家藏的钱，不能连续抢两家的钱，要求抢到尽量多的钱，求能抢到的最多的钱数。 Solution又一道动态规划的问题，当数组遍历至 i 位置时，pre2 表示 i - 2 位置的和, pre1 表示 i - 1 位置的和, curr 用于保存本轮结果。对于每个 i（i &gt; 3）都要做出这样一个选择：要 pre2 + nums[i] 还是要 pre1. 123456789101112131415161718192021class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) prev1,prev2,curr = 0, 0, 0 for i in nums: curr = max(i + prev2, prev1); prev2 = prev1; prev1 = curr; return curr","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"350. Intersection of Two Arrays II","slug":"intersection-of-two-arrays-ii","date":"2017-03-22T12:26:00.000Z","updated":"2017-06-13T07:32:31.000Z","comments":true,"path":"2017/03/22/intersection-of-two-arrays-ii/","link":"","permalink":"http://faramita.us/2017/03/22/intersection-of-two-arrays-ii/","excerpt":"","text":"DescriptionDifficulty: Easy Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order. Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 求两个数组交集。 Solution鉴于结果的顺序不限，依然使用我最喜欢的字典类型来实现。（字典类型实际上是哈希表，因此效率喜人）将两个数组转化为字典：key：数组中元素value：元素出现次数然后根据较短的字典构建数组：每个在短数组出现过的元素，若在长数组中也存在，则在结果数组中添加数个该元素，添加的数量为该元素在两个字典中各自出现次数中较小的一个次数。 12345678910111213141516171819202122232425262728def to_set(nums): nums_set = &#123;&#125; for i in nums: try: nums_set[i] += 1 except KeyError: nums_set[i] = 1 return nums_setclass Solution(object): def intersect(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" nums1_set = to_set(nums1) nums2_set = to_set(nums2) intersection = [] if len(nums1_set) &gt; len(nums2_set): nums1_set, nums2_set = nums2_set, nums1_set # 1 &lt; 2 for j in nums1_set: if j in nums2_set: intersection = intersection + ([j] * min(nums1_set[j], nums2_set[j])) return intersection","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"160. Intersection of Two Linked Lists","slug":"intersection-of-two-linked-lists","date":"2017-03-21T09:18:58.000Z","updated":"2017-06-13T07:32:27.000Z","comments":true,"path":"2017/03/21/intersection-of-two-linked-lists/","link":"","permalink":"http://faramita.us/2017/03/21/intersection-of-two-linked-lists/","excerpt":"","text":"DescriptionDifficulty: Easy Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 题意:两个链表，要求返回交叉点。 Solution先遍历一遍，确定二者的长度。从较长的一个开始遍历，直到二者长度相同，然后两个链表同时向后遍历，检测每一个点是不是点是不是相等遍历两次，时间复杂度 O(n),；新建四个指针，空间复杂度 O(1)。 1234567891011121314151617181920212223242526272829303132333435363738# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" pt_a, pt_b = headA, headB len_a, len_b = 0, 0 while pt_a: len_a += 1 pt_a = pt_a.next while pt_b: len_b += 1 pt_b = pt_b.next if len_a &gt; len_b: long, short = headA, headB else: long, short = headB, headA for diff in range(abs(len_a - len_b)): long = long.next common = None while long: if long == short: common = long break else: long, short = long.next, short.next return common","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"500. Keyboard Row","slug":"keyboard-row","date":"2017-03-19T17:07:00.000Z","updated":"2017-06-13T07:32:19.000Z","comments":true,"path":"2017/03/20/keyboard-row/","link":"","permalink":"http://faramita.us/2017/03/20/keyboard-row/","excerpt":"","text":"DescriptionDifficulty: Easy Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard. Example 1:Input: [“Hello”, “Alaska”, “Dad”, “Peace”]Output: [“Alaska”, “Dad”] Note:You may use one character in the keyboard more than once.You may assume the input string will only contain letters of alphabet. 给一组词（字母组成），返回一子集，其中单词可仅用键盘上某一行打出。 Solution先创建三个字符串，分别包含键盘上三行的字母（大小写），然后遍历每个单词后续字母是否与第一个字母在同一行；注意发现不同时跳过当前单词节省时间。 12345678910111213141516171819202122232425262728293031class Solution(object): def findWords(self, words): \"\"\" :type words: List[str] :rtype: List[str] \"\"\" row1 = 'qwertyuiopQWERTYUIOP' row2 = 'asdfghjklASDFGHJKL' row3 = 'zxcvbnmZXCVBNM' rslt = [] if words == []: return [] for i in words: lead = [] if i[0] in row1: lead = row1 elif i[0] in row2: lead = row2 elif i[0] in row3: lead = row3 diff = 0 for j in i: if j not in lead: diff = 1 break if diff == 0: rslt.append(i) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"14. Longest Common Prefix","slug":"longest-common-prefix","date":"2017-03-19T09:02:11.000Z","updated":"2017-06-13T07:32:06.000Z","comments":true,"path":"2017/03/19/longest-common-prefix/","link":"","permalink":"http://faramita.us/2017/03/19/longest-common-prefix/","excerpt":"","text":"DescriptionDifficulty: Easy Write a function to find the longest common prefix string amongst an array of strings. 题意:给出一 list，内容为一些字符串，找出这些字符串的最长公共前缀。 Solution先将前缀 prefix 定位 list 的第一个元素。对于之后的每一个元素，如果该元素比 prefix 短，则先将 prefix 切成相应长度。然后对比 prefix 与当前元素，遇到不同则将 prefix 切成不同点之前的部分。 12345678910111213141516171819202122232425class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if strs == []: return '' elif len(strs) == 1: return strs[0] prefix = strs[0] for s in strs[1:]: if s == '' or prefix == '': return '' prefix = prefix[:min(len(prefix), len(s))] for posi in range(len(prefix)): if prefix[posi] != s[posi]: prefix = prefix[:posi] break if len(prefix) == 0: return '' return prefix","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"169. Majority Element","slug":"majority-element","date":"2017-03-18T10:55:00.000Z","updated":"2017-06-13T07:32:00.000Z","comments":true,"path":"2017/03/18/majority-element/","link":"","permalink":"http://faramita.us/2017/03/18/majority-element/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 给一数列，找出众数。 Solution扫描一遍 nums，维护一个字典 xSet：key ：nums 中元素value：该元素出现次数再扫描一遍 xSet，找到出现次数大于 floor(len(nums)) 的元素，返回。 1234567891011121314151617import mathclass Solution(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" xSet = &#123;&#125; for i in nums: try: xSet[i] += 1 except KeyError: xSet[i] = 1 for j in xSet: if xSet[j] &gt; math.floor(len(nums) / 2): return j","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"53. Maximum Subarray","slug":"maximum-subarray","date":"2017-03-17T07:00:18.000Z","updated":"2017-03-17T09:29:28.000Z","comments":true,"path":"2017/03/17/maximum-subarray/","link":"","permalink":"http://faramita.us/2017/03/17/maximum-subarray/","excerpt":"","text":"DescriptionDifficulty: Easy Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. click to show more practice. More practice:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 题意:给出一数组 nums，求数组中和最大的连续子序列。 Solution最简单的想法自然是枚举所有大小的窗口，从 len(nums) 到 1；滑动窗口到每个可能的位置，求和，记录和的最大值。代码如下： 123456789101112131415161718192021222324252627282930313233class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # base cases if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] # window size init as len(nums) - 1 window = len(nums) - 1 # window position init as right start = len(nums) - window # this is the case when window size = len(nums) # and this will store the max of sums sum_max = sum(nums) # every possible window size: [1, len(nums) - 1] while window &gt; 0: # every possible position of this window while start &gt;= 0: sum_curr = sum(nums[start:start+window]) sum_max = max(sum_curr, sum_max) # window slides left start -= 1 # window size minus 1 window -= 1 # reset window position to the very right start = len(nums) - window return sum_max 不用说，这么 virgin 这么 naive 的算法当然是无法满足时间复杂度要求的。之后，我考虑窗口从 1 开始，用字典储存所有算过的 sum，下次使用时直接读取而不用再算一遍。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142def maxSubArray(nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # base cases length = len(nums) if length == 0: return 0 elif length == 1: return nums[0] # all possible window sizes in [1, length - 1] window = 1 # all possible positions from right start = len(nums) - window # stroe the max of sums sum_max = sum(nums) # store all sums for every position of every window sizes sum_set = &#123;&#125; while window &lt; length: while start &gt;= 0: # store all single \"sums\" if window == 1: sum_curr = nums[start] # get current sum by last round sum + single \"sum\" elif window &gt; 1: sum_curr = sum_set[(start, start + window - 1)] + nums[start + window - 1] # store current sum sum_set[(start, start+window)] = sum_curr # print(nums[start:start+window], sum_curr, sum_max) # store current max sum sum_max = max(sum_curr, sum_max) # slide the window start -= 1 # enlarge the window size window += 1 # and reset the position of the window start = len(nums) - window return sum_max 这个算法则将执行时间从原来的 2.5s 优化到了 1s 以内。但是时间复杂度依然是 O(n^2) 这道题是可以用动态规划的。遍历到每个节点时都有两个选择：选择上一个 sum 加当前数，或者选择当前数作为新的 sum。算法如下： 12345678910def maxSubArray(A): if not A: return 0 curSum = maxSum = A[0] for num in A[1:]: curSum = max(num, curSum + num) maxSum = max(maxSum, curSum) return maxSum P.S 写这道题的时候 LeetCode 挂了…… 🤦","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"4. Median of Two Sorted Arrays","slug":"median-of-two-sorted-arrays","date":"2017-03-16T03:28:00.000Z","updated":"2017-06-13T07:31:47.000Z","comments":true,"path":"2017/03/16/median-of-two-sorted-arrays/","link":"","permalink":"http://faramita.us/2017/03/16/median-of-two-sorted-arrays/","excerpt":"","text":"DescriptionDifficulty: Hard There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example1nums1 = [1, 3]nums2 = [2] The median is 2.0 Example2nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 给出两个有序数列，返回两个数列形成的大数列的中位数。 Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" # pointers for two lists p1 = 0 p2 = 0 isOdd = True # last nums last = 0 if (len(nums1) + len (nums2)) % 2 == 1: exp_num = (len(nums1) + len (nums2) + 1) / 2 isOdd = True else: exp_num = ((len(nums1) + len (nums2)) / 2) + 1 isOdd = False if len(nums1) == 0 or len(nums2) == 0: comb = nums1 + nums2 if isOdd == True: return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) elif nums1[-1] &lt;= nums2[0]: comb = nums1 + nums2 if isOdd == True: return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) elif nums2[-1] &lt;= nums1[0]: comb = nums2 + nums1 if isOdd == True: print(comb[exp_num]) return comb[exp_num - 1] else: return (comb[exp_num - 1] + comb[exp_num - 2]) / float(2) while p1 + p2 &lt;= exp_num - 2: if p1 &gt;= len(nums1): last = nums2[p2] p2 += 1 elif p2 &gt;= len(nums2): last = nums1[p1] p1 += 1 elif nums1[p1] &lt; nums2[p2]: last = nums1[p1] p1 += 1 else: last = nums2[p2] p2 += 1 if p1 &gt;= len(nums1): toAdd = nums2[p2] elif p2 &gt;= len(nums2): toAdd = nums1[p1] else: toAdd = min(nums1[p1], nums2[p2]) if isOdd == True: return toAdd else: return (toAdd + last) / float(2)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"88. Merge Sorted Array","slug":"merge-sorted-array","date":"2017-03-15T08:31:03.000Z","updated":"2017-06-13T07:31:42.000Z","comments":true,"path":"2017/03/15/merge-sorted-array/","link":"","permalink":"http://faramita.us/2017/03/15/merge-sorted-array/","excerpt":"","text":"DescriptionDifficulty: Easy Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 题意:给两个有序数组 nums1、nums2，将两个数组原地合并到 nums1，保持 nums1 有序。 Solution与归并排序类似，但是从头部开始归并的成本太高，而 nums1 又有足够的长度，因此从两数组的尾部开始归并，放在 nums1 尾部（从 m + n - 1 开始）。 1234567891011121314151617181920212223242526class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" if n == 0: return p1, p2 = m - 1, n - 1 # 2 working pointers init at the ends for i in range(m + n - 1, -1, -1): if p1 &lt; 0: nums1[i] = nums2[p2] p2 -= 1 elif p2 &lt; 0: nums1[i] = nums1[p1] p1 -= 1 elif nums1[p1] &gt; nums2[p2]: nums1[i] = nums1[p1] p1 -= 1 elif nums1[p1] &lt;= nums2[p2]: nums1[i] = nums2[p2] p2 -= 1","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"155. Min Stack","slug":"min-stack","date":"2017-03-14T10:29:32.000Z","updated":"2017-06-13T07:31:38.000Z","comments":true,"path":"2017/03/14/min-stack/","link":"","permalink":"http://faramita.us/2017/03/14/min-stack/","excerpt":"","text":"DescriptionDifficulty: Easy Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. 题意:自己实现一个栈，除了推、弹、查看栈顶以外还要求常数时间找到栈中最小值。 Solution基本思路是使用 list 结构，自带 push（append）与 pop 方法。top 只需要返回最后一个元素。对于最小值，最单纯的思路是用自带方法返回 min(list)，但是时间复杂度不允许。因此维护一个最小值 stack，在每次 push 的时顺便在最小值 stack 中 push 当前最小值（包括输入值），每次 pop 时最小值栈也随之 pop。需要获取最小值时只需要获取最小值 stack 的最后一个元素即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.stack = [] self.min_q = [] def push(self, x): \"\"\" :type x: int :rtype: void \"\"\" self.stack.append(x) if self.min_q == []: self.min_q.append(x) else: self.min_q.append(min(x, self.min_q[-1])) def pop(self): \"\"\" :rtype: void \"\"\" self.stack.pop() self.min_q.pop() def top(self): \"\"\" :rtype: int \"\"\" return self.stack[-1] def getMin(self): \"\"\" :rtype: int \"\"\" return self.min_q[-1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin()","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"268. Missing Number","slug":"missing-number","date":"2017-03-13T12:46:00.000Z","updated":"2017-06-13T07:31:32.000Z","comments":true,"path":"2017/03/13/missing-number/","link":"","permalink":"http://faramita.us/2017/03/13/missing-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example,Given nums = [0, 1, 3] return 2. Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 给一数组，给出数组与 [0,1,2,3,4,…,n] 相比缺少的一个数。所给数组可为任意顺序。 Solution先排序。分析一下情况：数组长度为 0：缺 1数组长度为 1：有两种情况（因为只能缺一个数）[0], [1]；分别返回 1, 0数组更长：若第一个元素不是 0，则返回 0；设两个指针从开头遍历，若后一个减前一个大于 1，则返回前一个 + 1；若一直连续，这返回最后一个元素 + 1 12345678910111213141516class Solution(object): def missingNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums.sort() if len(nums) == 0 or nums[0] != 0: return 0 elif nums == [0]: return 1 else: for i in xrange(len(nums) - 1): if nums[i + 1] - nums[i] &gt; 1: return nums[i] + 1 return nums[-1] + 1","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"一个交作业的小工具 v2.1","slug":"a-tool-for-homework-v2.1","date":"2017-03-13T11:40:32.000Z","updated":"2017-03-13T11:43:39.000Z","comments":true,"path":"2017/03/13/a-tool-for-homework-v2.1/","link":"","permalink":"http://faramita.us/2017/03/13/a-tool-for-homework-v2.1/","excerpt":"","text":"update:网页结构稍有变化，修改以适应；文件名获取方式更加可靠。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: UTF-8 -*-import sysimport timefrom pyquery import PyQuery as pqtmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**&#123;contents&#125;&lt;b&gt;题意:&lt;/b&gt;&lt;br&gt;## Solution&#123;% codeblock lang:text %&#125;&#123;% endcodeblock %&#125;'''url = sys.argv[1]d = pq(url)get_title = d('.question-title h3').text()get_difficulty = d('.question-info li strong').eq(2).text()get_filename = url.lstrip('https://').split('/')[2] + '.md'get_contents = (d('.question-content').html(method='html') .split('&lt;p&gt;&lt;a href=\"/subscribe/\"&gt;Subscribe&lt;/a&gt;')[0].rstrip().rstrip('&lt;div&gt;') .split('&lt;p&gt;&lt;b&gt;Credits:&lt;/b&gt;')[0].strip())tmp = tmp.format( title=get_title, difficulty=get_difficulty, contents=get_contents, date=time.strftime(\"%F %H:%M:%S\", time.localtime()))file = open(get_filename, 'w')file.write(tmp)file.close()# call(['vim', get_filename])print('Show time:\\n', get_filename) 人生苦短，我用 Python。","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"234. Palindrome Linked List","slug":"palindrome-linked-list","date":"2017-03-12T08:18:22.000Z","updated":"2017-06-13T07:31:24.000Z","comments":true,"path":"2017/03/12/palindrome-linked-list/","link":"","permalink":"http://faramita.us/2017/03/12/palindrome-linked-list/","excerpt":"","text":"DescriptionDifficulty: Easy Given a singly linked list, determine if it is a palindrome. Follow up:Could you do it in O(n) time and O(1) space? 题意:判断一个链表是否回文。 Solution最简单的想法是把链表的值按顺序输出到一个数组，在判断数组是否回文；判断数组是否回文，也就是判断前一半的逆序是否与后一半相等。 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if not head: return True link_list = [] p = head while p: link_list.append(p.val) p = p.next length = len(link_list) if length % 2 == 0: return link_list[:(length / 2)] == link_list[(length / 2):][::-1] else: return link_list[:(length / 2)] == link_list[(length / 2) + 1:][::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"118. Pascal's Triangle","slug":"pascals-triangle","date":"2017-03-11T15:31:29.000Z","updated":"2017-06-13T07:31:19.000Z","comments":true,"path":"2017/03/11/pascals-triangle/","link":"","permalink":"http://faramita.us/2017/03/11/pascals-triangle/","excerpt":"","text":"DescriptionDifficulty: Easy Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题意:给出行数，生成相应行帕斯卡三角。 Solution帕斯卡三角的下一行的某元素是上一行的相邻两元素的和。 123456789101112131415161718192021class Solution(object): def generate(self, numRows): \"\"\" :type numRows: int :rtype: List[List[int]] \"\"\" if numRows == 0: rslt = [] elif numRows == 1: rslt = [[1]] elif numRows == 2: rslt = [[1], [1, 1]] elif numRows &gt; 2: rslt = [[1], [1, 1]] for i in xrange(2, numRows): now = [1] for j in xrange(1, i): now.append(rslt[i-1][j-1] + rslt[i-1][j]) now.append(1) rslt.append(now) return rslt","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"66. Plus One","slug":"plus-one","date":"2017-03-10T15:13:18.000Z","updated":"2017-06-13T07:31:13.000Z","comments":true,"path":"2017/03/10/plus-one/","link":"","permalink":"http://faramita.us/2017/03/10/plus-one/","excerpt":"","text":"DescriptionDifficulty: Easy Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. 题意:给一个数组，每个元素表示一个数字的每一位，要求以相同形式给出这个数字加一的结果。 Solution难点在于进位，特别是由 n 位数变为 n + 1 位数时，如果每一位都移动代价太太。这里先将数组逆置，然后从头部（即末位）加一，进位完成后在逆置回来。 123456789101112131415161718class Solution(object): def plusOne(self, digits): \"\"\" :type digits: List[int] :rtype: List[int] \"\"\" digits_r = digits[::-1] added = False for i in xrange(len(digits)): if digits_r[i] + 1 &lt; 10: digits_r[i] += 1 added = True break elif digits_r[i] + 1 == 10: digits_r[i] = 0 if added == False: digits_r.append(1) return digits_r[::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"26. Remove Duplicates from Sorted Array","slug":"remove-duplicates-from-sorted-array","date":"2017-03-08T17:09:00.000Z","updated":"2017-06-13T07:31:08.000Z","comments":true,"path":"2017/03/09/remove-duplicates-from-sorted-array/","link":"","permalink":"http://faramita.us/2017/03/09/remove-duplicates-from-sorted-array/","excerpt":"","text":"DescriptionDifficulty: Easy Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 题意:原地为一个数组去重，返回不重复的数组长度 n 并且仅需保持该数组前 n 位为不重复的数组。 Solution虽然效率偏低，但是重复的删掉就好。 123456789101112131415161718192021222324class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt;= 1: return len(nums) elif len(nums) == 2: if nums[0] == nums[1]: return 1 else: return 2 # now,it has at least the length of 3 i = 1 while i &lt; len(nums): # if nums[tail] != nums[i]: # tail += 1 if nums[i-1] == nums[i]: del(nums[i]) else: i += 1 return len(nums) update：讨论中展示了一种简洁而优美的写法：123456789101112131415class Solution: # @param a list of integers # @return an integer def removeDuplicates(self, A): if not A: return 0 newTail = 0 for i in range(1, len(A)): if A[i] != A[newTail]: newTail += 1 A[newTail] = A[i] return newTail + 1 也就是将每一个不同的元素复制到 newTail 位置。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"一个交作业的小工具 v2.0","slug":"a-tool-for-homework-v2","date":"2017-03-08T13:32:32.000Z","updated":"2017-03-12T06:05:59.000Z","comments":true,"path":"2017/03/08/a-tool-for-homework-v2/","link":"","permalink":"http://faramita.us/2017/03/08/a-tool-for-homework-v2/","excerpt":"","text":"本版将参数减少到一个：题目的 URL。之后自动获取文件名、标题、描述、难度等等，只需填写题目解释、解题思路与代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/python# -*- coding: UTF-8 -*-import sysimport timefrom pyquery import PyQuery as pqtmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**&#123;contents&#125;## Solution&#123;% codeblock lang:text %&#125;&#123;% endcodeblock %&#125;'''url = sys.argv[1]d = pq(url)get_title = d('.question-title h3').text()get_difficulty = d('#DescriptionContent .question-info li strong').eq(2).text()get_filename = url.rstrip('?tab=Description').rstrip('/').split('/')[-1] + '.md'get_contents = (d('.question-content') .html(method='html') .split('&lt;div&gt;&lt;p&gt;&lt;a href=\"/subscribe/\"&gt;Subscribe&lt;/a&gt;')[0] .split('&lt;p&gt;&lt;b&gt;Credits:&lt;/b&gt;')[0] .strip())tmp = tmp.format( title=get_title, difficulty=get_difficulty, contents=get_contents, date=time.strftime(\"%F %H:%M:%S\", time.localtime()))file = open(get_filename, 'w')file.write(tmp)file.close()print('Show time:', get_filename) 下一版打算实现输入题号代替网址。 人生苦短，我用 Python。","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"一个交作业的小工具","slug":"a-tool-for-homework","date":"2017-03-08T08:58:32.000Z","updated":"2017-03-12T06:05:46.000Z","comments":true,"path":"2017/03/08/a-tool-for-homework/","link":"","permalink":"http://faramita.us/2017/03/08/a-tool-for-homework/","excerpt":"","text":"本博客基于 Hexo 搭建。Hexo 的文章格式虽然简单，但是每次手打也实在太麻烦。故写一小脚本帮助生成需要的作业格式。三个参数分别为文件名，标题与难度；除此以外还会自动填充当前时间。代码如下。 12345678910111213141516171819202122232425262728293031#!/usr/bin/python3# -*- coding: UTF-8 -*-import sysimport timetmp = '''---title: &#123;title&#125;tag: algorithmdate: &#123;date&#125;---## Description**Difficulty: &#123;difficulty&#125;**## Solution'''tmp = tmp.format( title=sys.argv[2], difficulty=sys.argv[3], date=time.strftime(\"%F %H:%M:%S\", time.localtime()))tmp += (r'&#123;% codeblock lang:python %&#125;' + '\\n\\n' + r'&#123;% endcodeblock %&#125;' + '\\n')file = open(sys.argv[1] + '.md', 'w')file.write(tmp)file.close()print(sys.argv[1] + '.md') 之后还会对信息填充进一步优化，如从网页自动获取问题描述等。 人生苦短，我用 Python。","categories":[],"tags":[{"name":"works","slug":"works","permalink":"http://faramita.us/tags/works/"}]},{"title":"344. Reverse String","slug":"reverse-string","date":"2017-03-08T03:28:00.000Z","updated":"2017-06-13T07:30:50.000Z","comments":true,"path":"2017/03/08/reverse-string/","link":"","permalink":"http://faramita.us/2017/03/08/reverse-string/","excerpt":"","text":"DescriptionDifficulty: Easy Write a function that takes a string as input and returns the string reversed. Example1Given s = “hello”, return “olleh”. 反转字符串。 Solution1234567class Solution(object): def reverseString(self, s): \"\"\" :type s: str :rtype: str \"\"\" return s[::-1]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"13. Roman to Integer","slug":"roman-to-integer","date":"2017-03-07T11:46:00.000Z","updated":"2017-03-07T11:51:39.000Z","comments":true,"path":"2017/03/07/roman-to-integer/","link":"","permalink":"http://faramita.us/2017/03/07/roman-to-integer/","excerpt":"","text":"DescriptionDifficulty: Easy Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 罗马数字转换为阿拉伯数字。 Solution一道很有趣的题。根据罗马数字左加右减的规则，在字符串长度大于 0 的情况下，每次取字符串第一个元素，若第一个元素是 IXC 其中一个且小于第二个元素，则总和加第二个元素减第一个元素，字符串修改为从第三个元素开始；若字符串长度为 1 或第一个元素不小于第二个元素，则总和加上第一个元素的值，字符串从第二个元素开始。返回总和。 123456789101112131415161718192021class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" dict = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; sum = 0 while len(s) &gt; 0: if len(s) == 1: sum += dict[s[0]] s = s[1:] elif dict[s[0]] &lt; dict[s[1]] and s[0] in 'IXC': sum += (dict[s[1]] - dict[s[0]]) s = s[2:] else: sum += dict[s[0]] s = s[1:] return sum","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"136. Single Number","slug":"single-number","date":"2017-03-06T03:28:00.000Z","updated":"2017-06-13T07:30:34.000Z","comments":true,"path":"2017/03/06/single-number/","link":"","permalink":"http://faramita.us/2017/03/06/single-number/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 给出一个整数数组，有一个元素只出现了一次，其他所有元素都出现了两次。找出这个元素。 Solution123456789101112131415class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" rslt = &#123;&#125; for i in nums: try: rslt[i] += 1 except KeyError: rslt[i] = 1 for j in rslt: if rslt[j] == 1: return j","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"7. Reverse Integer","slug":"string-to-integer-atoi","date":"2017-03-04T16:13:00.000Z","updated":"2017-06-13T07:30:28.000Z","comments":true,"path":"2017/03/05/string-to-integer-atoi/","link":"","permalink":"http://faramita.us/2017/03/05/string-to-integer-atoi/","excerpt":"","text":"DescriptionDifficulty: Medium Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Note: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. CheatSheetRequirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Solution123456789101112131415161718192021222324252627282930313233class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" str = str.strip() if str == '': return 0 neg = False nums = '0123456789' if str[0] == '-': neg = True str = str[1:] elif str[0] == '+': neg = False str = str[1:] if str == '' or str[0] not in nums: return 0 for i in xrange(len(str)): if str[i] not in nums: str = str[:i] break if str == '': return 0 if neg == False: return min(int(str), 2147483647) else: return max(-int(str), -2147483648)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"101. Symmetric Tree","slug":"symmetric-tree","date":"2017-03-04T11:20:39.000Z","updated":"2017-06-13T07:30:22.000Z","comments":true,"path":"2017/03/04/symmetric-tree/","link":"","permalink":"http://faramita.us/2017/03/04/symmetric-tree/","excerpt":"","text":"DescriptionDifficulty: Easy Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3Note:Bonus points if you could solve it both recursively and iteratively. 题意：输入一棵二叉树，判断是否纵向轴对称（与镜像相同）。 Solution只需要判断跟节点的左右子树是否镜像对称。也就是说只需要判断右子树翻转后是否与左子树相同即可。也就是以相同方式遍历左子树与翻转后的右子树，生成的值的数组相同即可。 方法 revrs_bt 用于反转二叉树；方法 mlr_walk 用于前序遍历二叉树；返回生成的两数组是否相等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Nonedef revrs_bt(node): head = node if node: node.left, node.right = revrs_bt(node.right), revrs_bt(node.left) return headdef mlr_walk(rslt, node): if node: rslt.append(node.val) try: mlr_walk(rslt, node.left) except AttributeError: rslt.append(None) try: mlr_walk(rslt, node.right) except AttributeError: rslt.append(None) return rsltclass Solution(object): def isSymmetric(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" if root == None or (root.left, root.right) == (None, None): return True t_l = root.left # left tree t_r = root.right # right tree t_r_r = revrs_bt(t_r) # reversed right tree rslt_l, rslt_r = [], [] rslt_l = mlr_walk(rslt_l, t_l) rslt_r = mlr_walk(rslt_r, t_r_r) return rslt_l == rslt_r","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"242. Valid Anagram","slug":"valid-anagram","date":"2017-03-03T11:11:00.000Z","updated":"2017-06-13T07:30:11.000Z","comments":true,"path":"2017/03/03/valid-anagram/","link":"","permalink":"http://faramita.us/2017/03/03/valid-anagram/","excerpt":"","text":"DescriptionDifficulty: Easy Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? 判断两个词是不是同字母异构词。 Solution维护两个字典：key：字符串中的元素value：元素出现的次数 返回两个字典是否相等 1234567891011121314151617def add_to_set(str): xSet = &#123;&#125; for i in str: try: xSet[i] += 1 except KeyError: xSet[i] = 1 return xSetclass Solution(object): def isAnagram(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" return add_to_set(s) == add_to_set(t)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"125. Valid Palindrome","slug":"valid-palindrome","date":"2017-03-02T05:49:24.000Z","updated":"2017-06-13T07:30:01.000Z","comments":true,"path":"2017/03/02/valid-palindrome/","link":"","permalink":"http://faramita.us/2017/03/02/valid-palindrome/","excerpt":"","text":"DescriptionDifficulty: Easy Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,“A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. Note:Have you consider that the string might be empty? This is a good question to ask during an interview.For the purpose of this problem, we define empty string as valid palindrome. 题意:给出一个字符串，判断是否为回文。要求： 空字符串为回文； 忽略非字母数字的字符； 大小写不敏感。 Solution算法并不难，字符串转小写，过滤非数字与非字母，切分字符串为前后两半，对比即可。OJ 的最后一个 test case 是一个长达 14380 行的复杂字符串，该算法可以在 0.07s 内完成判断。但是！这个算法依然超过了时间限制！F！ 123456789101112131415161718192021class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" if s == '': return True s = s.lower() s_clean = '' for c in s: if c.isalpha() or c.isdigit(): s_clean += c length = len(s_clean) if length % 2 == 0: s_l = s_clean[:length / 2] s_r = s_clean[length / 2:] else: s_l = s_clean[:(length - 1) / 2] s_r = s_clean[(length + 1) / 2:] return s_l == s_r[::-1] 于是我写了另一个算法，使用双指针原地执行。代码如下： 12345678910111213141516171819class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" head, tail = 0, len(s) - 1 while tail &gt; head: if not s[tail].isalnum(): tail -= 1 continue if not s[head].isalnum(): head += 1 continue if s[tail].lower() != s[head].lower(): return False tail -= 1 head += 1 return True 这个算法在处理上面提到的大字符串时运行时间稳定在 0.75s，然而 LeetCodeOJ 竟然判断通过。 当然，原地执行达到相似时间复杂度的确是更好的实践。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"20. Valid Parentheses","slug":"valid-parentheses","date":"2017-03-01T06:35:45.000Z","updated":"2017-06-13T07:29:52.000Z","comments":true,"path":"2017/03/01/valid-parentheses/","link":"","permalink":"http://faramita.us/2017/03/01/valid-parentheses/","excerpt":"","text":"DescriptionDifficulty: Easy Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 题意:输入一列括号组合，数出是否合法，即括号是否先打开后关闭并且以正确顺序关闭。 Solution实际上就是实现一个 stack。这里使用 dict 类型来判断左右括号是否对应。 123456789101112131415161718192021222324class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" left = &#123;'(': 0, '[': 1, '&#123;': 2&#125; # left dict right = &#123;')': 0, ']': 1, '&#125;': 2&#125; # right dict stack = [] # working stack for i in s: # every element in s if i in left: # if it's one of the lefts stack.append(i) # stack push elif i in right: # if it's one of the rights try: # try to pop tmp = stack.pop() except IndexError: # if nothing to pop, return False return False if left[tmp] != right[i]: # if they do not match, return False return False if stack == []: # stack must be empty return True else: return False","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"283. Move Zeroes","slug":"move-zeroes","date":"2017-02-28T14:07:00.000Z","updated":"2017-02-28T14:15:24.000Z","comments":true,"path":"2017/02/28/move-zeroes/","link":"","permalink":"http://faramita.us/2017/02/28/move-zeroes/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. 将数列中的所有 0 移到末尾，其他元素保持不变。要求原地执行 Solution设定工作指针初始为 0 位置，设定 tail 指针指向非 0 尾部。若工作指针指向元素为 0，则将该元素移动到 tail 位置，tail 前移一位；若工作指针指向元素非 0，工作指针后移一位，直至工作指针遇到 tail。实现如下： 123456789101112131415161718192021222324class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" # nums = moveZeroes_main(nums) length = len(nums) tail = length - 1 if length &gt; 1: for i in xrange(length-1, 0, -1): if nums[i] == 0: # if there are zeros at the end tail -= 1 else: break j = 0 while j &lt; tail: if nums[j] == 0: for k in xrange(j, tail): nums[k] = nums[k+1] nums[tail] = 0 tail -= 1 else: j += 1 最初考虑写一个递归的方法实现，每次讲末尾 0 和开头确定非 0 部分略去。但是 Python 的 list 每次切分时都会复制，因此不满足原地执行以及不使用 return 的要求。但是这个方法我很喜欢，无论如何还是附上 123456789101112131415def moveZeroes_main(nums): tail = len(nums) if tail &gt; 1: if nums[-1] == 0: # tail = len(''.join([str(i) for i in nums]).rstrip('0')) return moveZeroes_main(nums[:-1]) + [0] else: if nums[0] == 0: for j in xrange(1, tail): nums[j-1] = nums[j] nums[-1] = 0 return moveZeroes_main(nums) else: return [nums[0]] + moveZeroes_main(nums[1:tail]) return nums","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"463. Island Perimeter","slug":"island-perimeter","date":"2017-02-26T17:35:00.000Z","updated":"2017-02-27T16:00:00.000Z","comments":true,"path":"2017/02/27/island-perimeter/","link":"","permalink":"http://faramita.us/2017/02/27/island-perimeter/","excerpt":"","text":"DescriptionDifficulty: Easy You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 找 1 组成的「岛」的边界。 Solution1 与 0 交替时、以及 1 元素越界时为边界。定义了一个方法，探测该位置是否为 0，或坐标包含负数，或数组越界。对 1 周围元素使用这个方法，这些情况边界长度加一。 12345678910111213141516171819202122232425262728def testSurround(grid, perimeter, x, y): if x &lt; 0 or y &lt; 0: perimeter += 1 else: try: z = grid[x][y] except IndexError: perimeter += 1 else: if z == 0: perimeter += 1 return perimeterclass Solution(object): def islandPerimeter(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" perimeter = 0 for i in xrange(len(grid)): for j in xrange(len(grid[i])): if grid[i][j] == 1: perimeter = testSurround(grid, perimeter, i, j - 1) perimeter = testSurround(grid, perimeter, i, j + 1) perimeter = testSurround(grid, perimeter, i - 1, j) perimeter = testSurround(grid, perimeter, i + 1, j) return perimeter","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"3. Longest Substring Without Repeating Characters","slug":"longest-substring-without-repeating-characters","date":"2017-02-26T07:17:30.000Z","updated":"2017-06-13T07:27:24.000Z","comments":true,"path":"2017/02/26/longest-substring-without-repeating-characters/","link":"","permalink":"http://faramita.us/2017/02/26/longest-substring-without-repeating-characters/","excerpt":"","text":"DescriptionDifficulty: Medium Given a string, find the length of the longest substring without repeating characters. Example1:Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution重点是字符串超长时的执行效率。 我使用的方法：一个指针指向 substring 最右端，作为工作指针不停向右；另一个指针初始指向字符串开头；遇到重复时指向字符串开头的指针向右移动一个，即 substring 去掉头部一个字符，再检测指向 substring 最右端的指针指向的字母是否重复。 这样实现仅需要遍历一遍整个字符串。 12345678910111213141516171819202122class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) &lt;= 1: return len(s) sub = '' max_l = 0 i = 0 while i &lt; len(s): if s[i] not in sub: sub += s[i] max_l = max(max_l, len(sub)) i += 1 else: sub = sub[1:] return max_l","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"104. Maximum Depth of Binary Tree","slug":"maximum-depth-of-binary-tree","date":"2017-02-25T07:17:30.000Z","updated":"2017-06-13T07:27:11.000Z","comments":true,"path":"2017/02/25/maximum-depth-of-binary-tree/","link":"","permalink":"http://faramita.us/2017/02/25/maximum-depth-of-binary-tree/","excerpt":"","text":"DescriptionDifficulty: Easy Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Solution其实只是深度遍历，同时记录深度。此处使用最简单的中序遍历，stack 在押入节点的同时压入该节点高度，以便取出节点同时恢复高度。 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if root == None: return 0 myStack = [] node = root # working pointer treeDepth = 0 maxDepth = 0 while node != None or myStack != []: while node != None: # if still have left child treeDepth += 1 myStack.append((node, treeDepth)) node = node.left # run out of lefts now = myStack.pop() node = now[0] maxDepth = max(maxDepth, treeDepth) treeDepth = now[1] node = node.right return maxDepth","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"2. Add Two Numbers","slug":"add-two-numbers","date":"2017-02-24T16:01:00.000Z","updated":"2017-02-25T09:48:50.000Z","comments":true,"path":"2017/02/25/add-two-numbers/","link":"","permalink":"http://faramita.us/2017/02/25/add-two-numbers/","excerpt":"","text":"DescriptionDifficulty: Easy You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solution实现一个低位到高位的加法运算。注意进位即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" l_r = ListNode(0) head = l_r plus1 = 0 while l1 != None or l2 != None: if plus1 == 0: l_n = ListNode(0) l_r.next = l_n l_r = l_n if l1 == None: l_r.val = l2.val + plus1 elif l2 == None: l_r.val = l1.val + plus1 else: l_r.val = l1.val + l2.val + plus1 plus1 = 0 if l_r.val &gt;= 10: plus1 = 1 l_r.val = l_r.val - 10 if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if plus1 == 1: l_n = ListNode(1) l_r.next = l_n l_r = l_n return head.next","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"7. Reverse Integer","slug":"reverse-integer","date":"2017-02-24T07:17:30.000Z","updated":"2017-06-13T07:26:49.000Z","comments":true,"path":"2017/02/24/reverse-integer/","link":"","permalink":"http://faramita.us/2017/02/24/reverse-integer/","excerpt":"","text":"DescriptionDifficulty: Easy Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution123456789101112131415class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" x_s = str(x)[::-1] if x &lt; 0: x_s = '-' + x_s[:-1] if int(x_s) &gt; 2147483647 or int(x_s) &lt; -2147483648: return 0 else: return int(x_s)","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"Hello World!","slug":"hello-world","date":"2017-02-23T07:17:30.000Z","updated":"2017-06-13T07:27:45.000Z","comments":true,"path":"2017/02/23/hello-world/","link":"","permalink":"http://faramita.us/2017/02/23/hello-world/","excerpt":"","text":"终于有了一个足够强大的动机让我真正开始写博客。本博客的主要内容将是算法及其他编码的笔记，以及一些思考。","categories":[],"tags":[{"name":"thinking","slug":"thinking","permalink":"http://faramita.us/tags/thinking/"}]},{"title":"1. Two Sum","slug":"two-sum","date":"2017-02-23T04:12:30.000Z","updated":"2017-06-13T07:26:09.000Z","comments":true,"path":"2017/02/23/two-sum/","link":"","permalink":"http://faramita.us/2017/02/23/two-sum/","excerpt":"","text":"DescriptionDifficulty: Easy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution1234567891011class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j]","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]}]}