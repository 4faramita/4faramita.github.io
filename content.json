[{"title":"7. Reverse Integer","date":"2017-02-22T16:05:30.000Z","path":"2017/02/23/reverse-integer/","text":"DescriptionDifficulty: Easy Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution123456789101112131415class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" x_s = str(x)[::-1] if x &lt; 0: x_s = '-' + x_s[:-1] if int(x_s) &gt; 2147483647 or int(x_s) &lt; -2147483648: return 0 else: return int(x_s)","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"1. Two Sum","date":"2017-02-22T10:43:48.000Z","path":"2017/02/22/two-sum/","text":"DescriptionDifficulty: Easy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution1234567891011class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j]","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://faramita.us/tags/algorithm/"}]},{"title":"Hello World!","date":"2017-02-22T02:17:42.000Z","path":"2017/02/22/hello-world/","text":"终于有了一个足够强大的动机让我真正开始写博客。本博客的主要内容将是算法及其他编码的笔记，以及一些思考。","tags":[{"name":"thinking","slug":"thinking","permalink":"http://faramita.us/tags/thinking/"}]}]